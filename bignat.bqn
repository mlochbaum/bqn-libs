# Arithmetic on large natural numbers.

base â† âŠ‘ â€¢args âˆ¾ 2â‹†52
! 1=â€¢Type base â‹„ ! (âŒŠâŠ¸=âˆ§2âŠ¸â‰¤) base
l2b â† (base=2âŠ¸â‹†)âŠ¸Ã— 2â‹†â¼base  # 0 if not a power of two
! (âŒˆâˆ˜âˆšâŠ¸Ã—âŸ(0=l2b) base) â‰¤ 2â‹†53

_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}

Valid â† {
  1==ğ•©? âˆ§Â´1=â€¢TypeÂ¨ğ•©? âˆ§Â´(âŒŠâŠ¸=âˆ§0âŠ¸â‰¤âˆ§<âŸœbase)ğ•©? # List of integers in [0,base)
  (0<â‰ )â—¶âŸ¨1,0â‰ âŠ¢Â´âŸ©ğ•©? 1 ;                    # Highest-order one isn't 0
  0
}
Trim â† { ğ•© â†‘Ëœ -âŸœ1 _while_ (â‰¥â—¶âŸ¨0,0=-âŠ‘ğ•©Ë™âŸ©âŸœ1) â‰ ğ•© }

FromSmall â† {ğ•©<base? âŸ¨ğ•©âŸ©; dâˆ¾ğ•ŠbaseÃ·Ëœğ•©-dâ†base|ğ•©}
From â‡ {
  ğ•Šâ¼ğ•©: ! Valid ğ•© â‹„ ToNum ğ•© ;
  ! 1 = â€¢Type ğ•©
  ! (0â‰¤ğ•©) âˆ§ ğ•©<âˆ
  ! âŒŠâŠ¸=ğ•©
  ğ•©>ğ•©-1 ? 0âŠ¸<â—¶â†•â€¿FromSmall ğ•© ;  # any a<ğ•© is an exact float
  # ğ•© = mfÃ—2â‹†p, where âŒ½e is the binary expansion of p
  eâ€¿mf â† 2 {(1âŒˆâŒŠ)âŠ¸=ğ•©Ã·ğ•¨? eâ€¿mâ†(Ã—Ëœğ•¨)ğ•Šğ•© â‹„ aâ†âŒŠâŠ¸=râ†mÃ·ğ•¨ â‹„ âŸ¨eâˆ¾a,râŸa mâŸ©; âŸ¨â†•0,ğ•©âŸ©} ğ•©
  m â† FromSmall mf
  {
    0â‰ lâ†l2b ? pâ†+ËœâŠ¸+ËœÂ´âŒ½e â‹„ (0â¥ŠËœpâŒŠâˆ˜Ã·l) âˆ¾ âŸ¨2â‹†l|pâŸ© Mul m ;
    m MulÂ´ MulËœâŸ(/âŒ¾âŒ½e) âŸ¨2âŸ©  # do smaller multiplies first
  }
}
ToNum â‡ 0 { râ†ğ•¨+baseÃ—ğ•© â‹„ "inexact"!ğ•¨=base|r â‹„ r }Â´ âŠ¢
NearestNum â‡ {
  0â‰ lâ†l2b ? dâ†0âŒˆ(â‰ ğ•©)-âŒˆ53Ã·l â‹„ (2â‹†lÃ—d) Ã— 0 +âŸœ(baseâŠ¸Ã—)Â´ dâ†“ğ•© ;
  ! "Non power-of-2 bases not yet implemented"
}

Carry â† {
  b â† ğ•¨ âŠ£ 0           # Carry in
  g â† ğ•© â‰¥ base        # Generate
  p â† ğ•© = base-1      # Propagate
  i â† âŒˆ`âˆ˜Ã—âŸœ(1+â†•âˆ˜â‰ )Â¬p  # Start index of propagation chain
  a â† i âŠ gsâ†bâˆ¾g      # Active propagations
  c â† g âˆ¨ p âˆ§ a       # Carry from these positions
  r â† (ğ•© + bÂ»c) - cÃ—base
  âŸ¨r, câŠ¸Â«âŒ¾â‹ˆbâŸ©
}
_extend â† { ğ•¨ ğ”½â—‹((ğ•¨âŒˆâ—‹â‰ ğ•©)âŠ¸â†‘) ğ•© }
Add â‡ {
  ğ•¨ğ•Šâ¼ğ•©: ğ•©Subğ•¨; ğ•¨ğ•ŠËœâ¼ğ•©: ğ•©Subğ•¨;
  0âŠ¸<â—¶âŠ£â€¿âˆ¾Â´ Carry ğ•¨ +_extend ğ•©
}
Sub â‡ {
  ! ğ•¨ â‰¥â—‹â‰  ğ•©
  sâ€¿c â† 1 Carry ğ•¨ (âŠ£ + (base-1)-âŠ¢)_extend ğ•©
  ! 1 = c
  Trim s
}

Mul â‡ {
  512 < nâ†ğ•¨âŒŠâ—‹â‰ ğ•© ? # Karatsuba
    kâ†âŒŠnÃ·2
    # AddâŸœ((kâ¥Š0)âŠ¸âˆ¾){ğ”½Â´ğ”½Â¨Ë} ğ•¨ ğ•ŠâŒœâ—‹(kâŠ¸(â†‘â‹ˆâ†“)) ğ•©  but one less ğ•Š
    lâ€¿hâ€¿a â† ğ•¨ ğ•ŠÂ¨â—‹(âˆ¾âŸœ(<AddÂ´)kâŠ¸(â†‘â‹ˆâ†“)) ğ•©
    AddâŸœ((kâ¥Š0)âŠ¸âˆ¾)Â´ âŸ¨l, a Sub l Add h, hâŸ©
  ;
  0 = ğ•¨âŒŠâ—‹â‰ ğ•© ? â†•0 ;
  _mso â† { qâ†ğ•—
    sâ†o â† 0Â¨ğ•©                          # Sum, overflow (maintain âˆ§Â´s<q)
    p â† {câ†qâ‰¤aâ†ğ•©+Â«s â‹„ sâ†©a-cÃ—q â‹„ oâ†©c+Â«o â‹„ âŠ‘Â¨sâ€¿o}âˆ˜Ã—âŸœğ•©Â¨ ğ•¨
    (<Ë˜â‰Â¯1â†“>p) âˆ¾Â¨ sâ€¿o                  # Restore passed sums
  }
  Bb â† AddâŸœ(0âŠ¸âˆ¾)Â´
  _sp â† {tâ†âŒŠğ•©Ã·ğ•— â‹„ âŸ¨ğ•©-ğ•—Ã—t, tâŸ©}          # Split into top and bottom
  Sb â† base _sp
  M â† {
    (q â† Ã—Ëœbase) â‰¤ 2â‹†53 ?
    sâ€¿o â† ğ•¨ q _mso ğ•©
    Bb (Sb s) âˆ¾ {âˆ§Â´ğ•©<base?â‹ˆğ•©; <âŠ¸âˆ¾âŸœğ•ŠÂ´Sbğ•©} o
  ;
    s â† âŒˆâˆšbase  # Can represent one limb with two base s, but b>Ã—Ëœs-1
    m â† ğ•¨ (Bb base _mso)âŒœâ—‹(s _sp) ğ•©    # Result is +Â´â¥Š(Ã—âŒœËœ1â€¿s)Ã—m
    p â† { 0<l2b ? AddÂ¨âŸœ(0âŠ¸âˆ¾âŒ¾âŠ‘âŒ½)Ëm ; AddÂ´Â¨(+âŒœËœâ†•2)âŠ”m }
    AddâŸœ{Bb Sb sÃ—ğ•©}Â´ p
  }
  Trim ğ•¨Mğ•©
}

_compare â‡ {
  Full â† 0âŠ¸â‰¤â—¶âŸ¨ğ”½Ëœ,âŠ‘âŸœğ•¨ğ”½âŠ‘âŸœğ•©âŸ© Â· -âŸœ1 _while_ (0âŠ¸â‰¤â—¶âŸ¨0,âŠ‘âŸœğ•¨=âŠ‘âŸœğ•©âŸ©) -âŸœ1
  ğ•¨ =â—¶ğ”½â€¿Fullâ—‹â‰  ğ•©
}

Neg â‡ (!0=â‰ )âŠ¸âŠ¢
Signum â‡ Ã—âˆ˜â‰ 
Abs â‡ Conj â‡ âŠ¢

DivMod â‡ {
  ğ•¨ <_compare ğ•© ? âŸ¨â†•0, ğ•¨âŸ© ;
  "Non power-of-2 bases not yet implemented" ! 0â‰ lâ†l2b
  Mu â† (From 2â‹†l|âŠ£)âŠ¸Mul
  M2 â† (âŒŠâˆ˜Ã·âŸœlâ¥Š0Ë™) âˆ¾ Mu                 #  ğ•©Ã—2â‹†ğ•¨
  D2 â† âŒˆâˆ˜Ã·âŸœl (â†‘âŸ¨1âŸ©âŠ¸AddâŸ(âˆ¨Â´â‰ âŸœ0)â†“) -âŠ¸Mu  # âŒŠğ•©Ã·2â‹†ğ•¨
  Recip â† { # approximate (2â‹†ğ•¨-b)Ã·m given bâ€¿mâ†ğ•©, (2â‹†b-1)â‰¤m<2â‹†b
    ğ•¨â‰¤2 ? From âŒŠ3Ã—2â‹†ğ•¨-1 ;
    z â† (hâ†1+âŒŠğ•¨Ã·2) ğ•Š ğ•©
    xp â† -âŸœ(ğ•¨+2)âŠ¸D2Â´ ğ•©
    (z M2Ëœ ğ•¨Â¬h) Sub (h+h+2) D2 xp Mul z Mul z  # Newton
  }
  Log â† (âŒŠ2â‹†â¼âŠ¢Â´) + lÃ—â‰ -1Ë™              # âŒŠ2â‹†â¼ğ•©
  nâ€¿m â† 1+LogÂ¨ ğ•¨â€¿ğ•©
  p â† (nÂ¬m) Recip mâ€¿ğ•©
  r â† ğ•© Mul q â† (n+1) D2 p Mul ğ•¨       # Approximate quotient
  o â† ğ•¨ â‰¥_compareâŸœr{ğ”½â—¶âŸ¨Â¯1, ğ”½ SubâŸ©} ğ•©   # Required correction
  C â† AddâŸo
  âŸ¨(â‹ˆ1) C q, ğ•¨ Sub ğ•© C râŸ©
}
Div â‡ âŠ‘ DivMod

Fact â‡ { ğ•©â‰¤1? âŸ¨1âŸ©; ğ•¨ğ•Šn:
  Prod â† {2â‰¤lâ†â‰ ğ•© ? (âŒŠlÃ·2)(â†‘Mulâ—‹ğ•Šâ†“)ğ•© ; From Ã—Â´ğ•©} # Recurse to keep intermediates small
  Pri â† {/(2â‰¤â†•ğ•©){ğ•©>0âŒ¾(ğ•¨âŠ¸âŠ‘)ğ•©â‰ âŠ¸â¥Šğ•¨â†‘1}âŸâŠ‘Â´âŒ½â†•âŒˆâˆšğ•©}     # Primes <ğ•©
  p â† ğ•¨ PriâŠ˜(â‰¤/âŠ£) n+1                           # (save them in ğ•¨)
  s â† Prod 1âŠ¸<âŠ¸/ {ğ•Šp:pâ‹†+Â´2|{ğ•Š0:â†•0;ğ•ŠâŠ¸âˆ¾âŒŠğ•©Ã·p}n}Â¨ p # Swinging factorial
  s Mul MulËœ p ğ•Š âŒŠnÃ·2
}âˆ˜âŠ¢
