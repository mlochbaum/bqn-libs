# Arithmetic on large natural numbers.

base ← ⊑ •args ∾ 2⋆24
! 1=•Type base ⋄ ! (⌊⊸=∧2⊸≤) base
! base ≤ 2⋆53
l2b ← (base=2⊸⋆)⊸× 2⋆⁼base  # 0 if not a power of two

_while_ ← {𝔽⍟𝔾∘𝔽_𝕣_𝔾∘𝔽⍟𝔾𝕩}

Valid ← {
  1==𝕩? ∧´1=•Type¨𝕩? ∧´(⌊⊸=∧0⊸≤∧<⟜base)𝕩? # List of integers in [0,base)
  (0<≠)◶⟨1,0≠⊢´⟩𝕩? 1 ;                    # Highest-order one isn't 0
  0
}
Trim ← { 𝕩 ↑˜ -⟜1 _while_ (≥◶⟨0,0=-⊑𝕩˙⟩⟜1) ≠𝕩 }

FromSmall ← {𝕩<base? ⟨𝕩⟩; d∾𝕊base÷˜𝕩-d←base|𝕩}
From ⇐ {
  𝕊⁼𝕩: ! Valid 𝕩 ⋄ ToNum 𝕩 ;
  ! 1 = •Type 𝕩
  ! (0≤𝕩) ∧ 𝕩<∞
  ! ⌊⊸=𝕩
  𝕩>𝕩-1 ? 0⊸<◶↕‿FromSmall 𝕩 ;  # any a<𝕩 is an exact float
  # 𝕩 = mf×2⋆p, where ⌽e is the binary expansion of p
  e‿mf ← 2 {⌊⊸=𝕩÷𝕨? e‿m←(×˜𝕨)𝕊𝕩 ⋄ a←⌊⊸=r←m÷𝕨 ⋄ ⟨e∾a,r⍟a m⟩; ⟨↕0,𝕩⟩} 𝕩
  m ← FromSmall mf
  {
    0≠l←l2b ? p←+˜⊸+˜´⌽e ⋄ (0⥊˜p⌊∘÷l) ∾ ⟨2⋆l|p⟩ Mul m ;
    m Mul´ Mul˜⍟(/⌾⌽e) ⟨2⟩  # do smaller multiplies first
  }
}
ToNum ⇐ 0 { r←𝕨+base×𝕩 ⋄ "inexact"!𝕨=base|r ⋄ r }´ ⊢
NearestNum ⇐ {
  0≠l←l2b ? d←0⌈(≠𝕩)-⌈53÷l ⋄ (2⋆l×d) × 0 +⟜(base⊸×)´ d↓𝕩 ;
  ! "Non power-of-2 bases not yet implemented"
}

Carry ← {
  b ← 𝕨 ⊣ 0           # Carry in
  g ← 𝕩 ≥ base        # Generate
  p ← 𝕩 = base-1      # Propagate
  i ← ⌈`∘×⟜(1+↕∘≠)¬p  # Start index of propagation chain
  a ← i ⊏ gs←b∾g      # Active propagations
  c ← g ∨ p ∧ a       # Carry from these positions
  r ← (𝕩 + b»c) - c×base
  ⟨r, c⊸«⌾⋈b⟩
}
_extend ← { 𝕨 𝔽○((𝕨⌈○≠𝕩)⊸↑) 𝕩 }
Add ⇐ {
  𝕨𝕊⁼𝕩: 𝕩Sub𝕨; 𝕨𝕊˜⁼𝕩: 𝕩Sub𝕨;
  0⊸<◶⊣‿∾´ Carry 𝕨 +_extend 𝕩
}
Sub ⇐ {
  ! 𝕨 ≥○≠ 𝕩
  s‿c ← 1 Carry 𝕨 (⊣ + (base-1)-⊢)_extend 𝕩
  ! 1 = c
  Trim s
}

Mul ⇐ {
  512 < n←𝕨⌊○≠𝕩 ? # Karatsuba
    k←⌊n÷2
    # Add⟜((k⥊0)⊸∾){𝔽´𝔽¨˝} 𝕨 𝕊⌜○(k⊸(↑⋈↓)) 𝕩  but one less 𝕊
    l‿h‿a ← 𝕨 𝕊¨○(∾⟜(<Add´)k⊸(↑⋈↓)) 𝕩
    Add⟜((k⥊0)⊸∾)´ ⟨l, a Sub l Add h, h⟩
  ;
  0 = 𝕨⌊○≠𝕩 ? ↕0 ;
  q ← ×˜base                           # Maintain ∧´s<q
  s←o ← 0¨𝕩                            # Sum, overflow
  p ← {c←q≤a←𝕩+«s ⋄ s↩a-c×q ⋄ o↩c+«o ⋄ ⊑¨s‿o}∘×⟜𝕩¨ 𝕨
  s‿o ∾˜¨↩ <˘⍉¯1↓>p                    # Restore passed sums
  Sp ← {t←⌊𝕩÷base ⋄ ⟨𝕩-base×t, t⟩}     # Split into top and bottom
  Trim Add⟜(0⊸∾)´ (Sp s) ∾ {∧´𝕩<base?⋈𝕩; <⊸∾⟜𝕊´Sp𝕩} o
}

_compare ⇐ {
  Full ← 0⊸≤◶⟨𝔽˜,⊑⟜𝕨𝔽⊑⟜𝕩⟩ · -⟜1 _while_ (0⊸≤◶⟨0,⊑⟜𝕨=⊑⟜𝕩⟩) -⟜1
  𝕨 =◶𝔽‿Full○≠ 𝕩
}

Neg ⇐ (!0=≠)⊸⊢
Signum ⇐ ×∘≠
Abs ⇐ Conj ⇐ ⊢

DivMod ⇐ {
  𝕨 <_compare 𝕩 ? ⟨↕0, 𝕨⟩ ;
  "Non power-of-2 bases not yet implemented" ! 0≠l←l2b
  Mu ← (From 2⋆l|⊣)⊸Mul
  M2 ← (⌊∘÷⟜l⥊0˙) ∾ Mu                 #  𝕩×2⋆𝕨
  D2 ← ⌈∘÷⟜l (↑⟨1⟩⊸Add⍟(∨´≠⟜0)↓) -⊸Mu  # ⌊𝕩÷2⋆𝕨
  Recip ← { # approximate (2⋆𝕨-b)÷m given b‿m←𝕩, (2⋆b-1)≤m<2⋆b
    𝕨≤2 ? From ⌊3×2⋆𝕨-1 ;
    z ← (h←1+⌊𝕨÷2) 𝕊 𝕩
    xp ← -⟜(𝕨+2)⊸D2´ 𝕩
    (z M2˜ 𝕨¬h) Sub (h+h+2) D2 xp Mul z Mul z  # Newton
  }
  Log ← (⌊2⋆⁼⊢´) + l×≠-1˙              # ⌊2⋆⁼𝕩
  n‿m ← 1+Log¨ 𝕨‿𝕩
  p ← (n¬m) Recip m‿𝕩
  r ← 𝕩 Mul q ← (n+1) D2 p Mul 𝕨       # Approximate quotient
  o ← 𝕨 ≥_compare⟜r{𝔽◶⟨¯1, 𝔽 Sub⟩} 𝕩   # Required correction
  C ← Add⍟o
  ⟨(⋈1) C q, 𝕨 Sub 𝕩 C r⟩
}
Div ⇐ ⊑ DivMod

Fact ⇐ { 𝕩≤1? ⟨1⟩; 𝕨𝕊n:
  Prod ← {2≤l←≠𝕩 ? (⌊l÷2)(↑Mul○𝕊↓)𝕩 ; From ×´𝕩} # Recurse to keep intermediates small
  Pri ← {/(2≤↕𝕩){𝕩>0⌾(𝕨⊸⊑)𝕩≠⊸⥊𝕨↑1}⍟⊑´⌽↕⌈√𝕩}     # Primes <𝕩
  p ← 𝕨 Pri⊘(≤/⊣) n+1                           # (save them in 𝕨)
  s ← Prod 1⊸<⊸/ {𝕊p:p⋆+´2|{𝕊0:↕0;𝕊⊸∾⌊𝕩÷p}n}¨ p # Swinging factorial
  s Mul Mul˜ p 𝕊 ⌊n÷2
}∘⊢
