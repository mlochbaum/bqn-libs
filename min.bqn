âŸ¨
  Min1
  _powell
  _nelderMead
âŸ©â‡

_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}

#âŒœ
# Nelder and Mead's downhill simplex method
NelderMead_sub â† { Fnâ€¿excessvolâ€¿pts:
  beta_vol â† 2â‹†â¼|betas â† Â¯0.5â€¿1â€¿2

  fp â† FnÂ¨ pts
  fpâ€¿pts (â‹fp)âŠ¸âŠÂ¨â†© 

  # Perform one step and return log base 2 of change in volume
  Loop â† {ğ•¤
    centroid â† (+ËÃ·â‰ ) Â¯1â†“pts
    # Points to try: linear combinations of the centroid and worst
    try â† centroid (âŠ£ + betasÃ—-) Â¯1âŠpts
    min â† âŒŠË ft â† FnÂ¨ try
    p â† âŠ‘ fp â‹ min            # Place relative to existing points
    p < â‰ fp ?
      # New point improves on at least one other
      i â† âŠ‘ ft âŠ min
      ptsâ€¿fp {p (â†‘âˆ¾ğ•©Â»â†“) ğ•¨}Â¨â†© âŸ¨iâŠtry,minâŸ©
      i âŠ‘ beta_vol            # Volume changes proportional to beta
    ;
      # New point is still the worst
      fp â†© FnÂ¨ pts (2Ã·Ëœ+)âŸœâŠâ†©  # Contract towards best point
      fpâ€¿pts (â‹fp)âŠ¸âŠÂ¨â†©        # Reorder
      1-â‰ pts                  # Volume shrinks by half in each dimension
  }

  # Keep going until volume decreases enough
  LoopâŠ¸+ _while_ (0âŠ¸<) excessvol
  âŸ¨âŠ‘pts, âŠ‘fpâŸ©
}

_nelderMead â† {
  simplex â† âŸ¨ğ•©âŸ©âˆ¾ğ•©âŠ¸+Â¨<âŠ¸=â†•â‰ ğ•©
  NelderMead_sub âŸ¨ğ”½, (â‰ ğ•©)Ã—(-2â‹†â¼ğ•¨)âŠ£15, simplexâŸ©
}


#âŒœ
# 1-dimensional minimization, beginning at interval Â¯1â€¿1
# Return âŸ¨argument, valueâŸ© for a local minimum
Min1 â† { tol ğ•Š f:
  phi â† 2Ã·Ëœ1+âˆš5  # golden ratio
  phi2 â† 2 - phi
  max_iter â† 100

  # Find initial minimum range, with steps increasing by factors of phi
  Init â† âˆ¾{
    v â† (âŠ¢ + phi Ã— -Ëœ)Â´ Â¯2â†‘ğ•¨
    (vğ”½ğ•¨) (â‰¤Â´1â†“âŠ¢)â—¶âŸ¨Â«_ğ•£,â‰Ë˜âŸ© (F v)ğ”½ğ•©
  }
  val â† âˆ§ {ğ•¨ Initâ—‹((â’ğ•©)âŠ¸âŠ) ğ•©}âŸœF Â¯1â€¿1

  # Decrease bounding interval to tolerance
  eâ†dâ†0                      # Distance on two previous steps
  bounds â† âŠË˜ 0â€¿Â¯1âŠval       # Possible range
  mins â† 3âŠ¸â¥ŠÂ¨ 1âŠval          # Lowest 3 values; initially same

  iter â† 0
  âŠ¢_while_ {ğ•¤
    # Conditions
    max_iter > iter+â†©1 ?
    Â¯âˆ < âŠ‘1âŠ‘mins ?
    bx â† bounds - âŠ‘âŠ‘mins
    (2Ã—tol) < -âŠ¸âŒˆÂ´bx ?

    # Compute sign s, distance d, saved distance e
    sâ†@ â‹„ sâ€¿dâ€¿e â†© {
      tol<e? 2<iter?
      # Parabolic interpolation
      rq â† (âŠ‘ - 1âŠ¸â†“)Â¨ mins
      a â† | dn â† (Ã—ËœâŠ¸Ã— 0âŠ¸â‰ â—¶âˆâ€¿Ã·âŸœ(Â¯2âŠ¸Ã—)â—‹(-Â´) Ã—)âŸœâŒ½Â´ rq
      =Ëœdn ?              # Not NaN
      e > 2Ã—a ?           # Movement needs to decrease enough
      tol < -âŠ¸âŒŠÂ´ bx-dn ?  # Stay away from bounds
      âŸ¨Ã—dn,a,dâŸ©
    ;
      # Non-interpolation method: golden split of smaller half
      a â† | b â† -âŠ¸<Â´âŠ¸âŠ‘ bx
      âŸ¨Ã—b,phi2Ã—a,aâŸ©
    }

    x â† âŠ‘âŠ‘mins
    uf â† F u â† x + sÃ—tolâŒˆd               # Move at least tol from x

    i â† 0 < p â† âŠ‘ (1âŠ‘mins) â‹ uf          # Position of u
    bounds â†© (iâŠ‘xâ€¿u)Ë™âŒ¾((i=0<s)âŠ¸âŠ‘) bounds # Tighten bounds; always drop one
    mins {p (â†‘âˆ¾ğ•©Â»â†“) ğ•¨}Â¨â†© uâ€¿uf            # Three lowest points; might discard u and keep all
    1;0
  }@

  âŠ‘Â¨ mins
}

# linear minimizer in multidimensions
# y is (initial value â‰ direction vector);(tolerance)
# returns (lowest point);(function value)
_linmin â† { ğ”½_ğ•£ startâ€¿dirâ€¿tol:
  Trans â† start + dirâŠ¸Ã—
  Fn â† ğ”½âˆ˜Transâš‡0
  TransâŒ¾âŠ‘ tol Min1 fn
}


#âŒœ
# (Enhanced) Powell's direction-set method

# Works with a set of directions, one for each dimension
# Idea is to optimize in all directions in order, then possibly add the
# total distance travelled as a new direction

Powell_sub â† { Fnâ€¿Minâ€¿pâ€¿tolâ€¿max_iter:
  fp â† Fn p     # Current function value
  pt â† p        # Baseline to find new directions
  dp â† <âŠ¸= â†•â‰ p  # Initialize direction set with basis vectors

  iter â† 0
  âŠ¢_while_ {ğ•¤
    max_iter > iter+â†©1 ?
    fi â† fp

    # Minimize in each direction successively, and record change in f
    df â† { f0â†fp â‹„ pâ€¿fpâ†©Min pâ€¿ğ•© â‹„ f0-fp }Â¨ dp

    # Relative tolerance
    (2Ã—|fi-fp) > tol Ã— fi +â—‹| fp ?

    dt â† p - pt
    fe â† Fn pe â† p + dt  # Extrapolate
    pt â†© p               # Starting point for next dt

    # Now fi â†’ fp â†’ fe are successive values separated by dt
    # Consider adding dt to the direction set
    # Replace the direction of largest increase to maintain independence
    { fe < fi ?
      mdf â† âŒˆÂ´df          # Largest decrease
      d2f â† fi+fe - 2Ã—fp  # Approximate second derivative wrt dt
      (2Ã—d2f Ã— Ã—Ëœ (fp+mdf)-fi) < mdf Ã— Ã—Ëœ fe-fi ?
      pâ€¿fp â†© Min pâ€¿dt
      dp dtâŒ¾((âŠ‘dfâŠmdf)âŠ¸âŠ‘)â†©
    ;@}
    1;0
  }@

  pâ€¿fp
}

_powell â† {
  tol â† ğ•¨âŠ£1eÂ¯10
  step â† Ã·4
  ltol â† 1eÂ¯4
  Powell_sub âŸ¨ğ”½, ğ”½ _linmin {pâ€¿d:ğ•©â‹„âŸ¨p,stepÃ—d,ltolâŸ©}, ğ•©, tol, 50Ã—â‰ ğ•©âŸ©
}
