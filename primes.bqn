âŸ¨
  PrimesTo
  PrimesIn, SieveSegment
  NextPrime, PrevPrime
  Pi
  IsPrime
  Factor, FactorExponents
  FactorCounts
  Totient
âŸ©â‡

# Wheel factorization
MakeWheel â† {
  len â‡ Ã—Â´primes â‡ ğ•©     # Primes in wheel and wheel length
  mask â‡ âˆ§Â´(lenâ¥Š0<â†•)Â¨primes
  numc â‡ â‰  coprime â‡ /mask

  # Get prime mask on segment [start,end) with prime divisors pd
  # Assumes pd doesn't intersect primes, or [start,end)
  Sieve â‡ {pd ğ•Š startâ€¿end:
    wâ†coprime,wnâ†numc,wlâ†len
    bcâ€¿ep â† wl (âŒŠâˆ˜Ã·Ëœ â‰â—‹< wâ‹|) (ğ•©-1)Ã·âŒœpd

    # Do first partial wheels together
    m â† â‰ Ëbc
    Uâ†{âŸ¨râ†ğ•©-ğ•¨,(âŠ’/r)+r/ğ•¨âŸ©} #{âŸ¨râ†ğ•©-ğ•¨,((â†•Â·âŠ‘Â¯1âŠ¸â†‘)+r/ğ•¨-Â»)+`râŸ©}
    frâ€¿fk â† UâŸœ((mÃ—wn)âŠ¸âŒˆ)Ë ep
    j â† (fr/pd) Ã— (fr/wlÃ—âŠbc) + fkâŠw

    # Then the remainder for each prime spanning multiple wheels
    Rem â† {pâ€¿sâ€¿eâ€¿o: # prime, start, end, overflow
      plâ†pÃ—wl â‹„ pwâ†start-ËœpÃ—w
      âŸ¨â¥Š(plÃ—s+â†•e-s)+âŒœpw, (plÃ—e)+oâ†‘pwâŸ©
    }
    b â† RemË˜ â‰>mâŠ¸/Â¨âŸ¨pd,1+âŠbc,1âŠbc,1âŠepâŸ©

    i â† âˆ¾ âŸ¨j-startâŸ©âˆ¾â¥Šb
    0Â¨âŒ¾(iâŠ¸âŠ) (end-start)â¥ŠstartâŒ½mask
  }
}

# Prime state
next â† 11
âŸ¨SieveâŸ© â† wheel â† MakeWheel 2â€¿3â€¿5â€¿7
wlen â† â‰  wheel.primes
primes â† wheel.primes
Extend â† {
  E â† {
    next â†© âŒˆ ğ•© âŒŠ ((2â‹†22)âŠ¸+ âŒŠ Ã—Ëœ) oldâ†next
    primes âˆ¾â†© old + / (wlenâ†“primes(â‹â†‘âŠ£)âˆšnext) Sieve oldâ€¿next
    ğ•ŠâŸ(nextâŠ¸<) ğ•©
  }
  next Eâˆ˜(2âŠ¸Ã—âŠ¸âŒˆ)âŸ< ğ•©
}

CheckNum  â† "Argument must be a non-negative number" ! (1=â€¢Type)â—¶âŸ¨0,0âŠ¸â‰¤âŸ©
CheckNat  â† "Argument must be a natural number" ! (1=â€¢Type)â—¶âŸ¨0,|âˆ˜âŒŠâŠ¸=âŸ©

PrimesTo â† {
  CheckNum ğ•©
  Extend ğ•©
  primes (â‹â†‘âŠ£) ğ•©
}

_getSegment â† {ind _ğ•£:
  PRange â† { primes (âŠ£âŠËœÂ·(âŠ£+â†•âˆ˜-Ëœ)Â´â‹) ğ•©-1 }
  sn â† {âŠ‘âˆ˜âŠ¢+/âˆ˜ğ•}âŸğ•— sieve
  pr â† {-ËœÂ´ â†‘ Â·/â¼ğ•-âŠ‘}âŸ(Â¬ğ•—) prange
  S â† {pd ğ•Š sâ€¿e:
    n â† nextâŒŠe
    (PR sâ€¿n) âˆ¾ <Â´â—¶âŸ¨âŸ©â€¿SN nâ€¿e
  }
  # IsPrimeÂ¨âŠ¸(ğ•—â—¶âŠ£â€¿/) start(âŠ£+â†•âˆ˜-Ëœ)end
  {ğ•Š startâ€¿end:
    CheckNatÂ¨ ğ•©
    "Range must be ordered" ! â‰¤Â´ğ•©
    (wlen â†“ PrimesTo âˆšend-1) (nextâ‰¤start)â—¶Sâ€¿SN ğ•©
  }
}
SieveSegment â† 0 _getSegment  # IsPrimeÂ¨   (âŠ£+â†•âˆ˜-Ëœ)Â´
PrimesIn     â† 1 _getSegment  # IsPrimeÂ¨âŠ¸/ (âŠ£+â†•âˆ˜-Ëœ)Â´

NextPrime â† {        (0<â‰ )â—¶âŸ¨ğ•Š1âŠ‘R,  âŠ‘ âŸ© PrimesIn râ†  ğ•©+1â€¿65 }âš‡0
PrevPrime â† { !2<ğ•© â‹„ (0<â‰ )â—¶âŸ¨ğ•Š0âŠ‘R,Â¯1âŠ‘âŠ¢âŸ© PrimesIn râ†1âŒˆğ•©-64â€¿0 }âš‡0

# Number of primes less than ğ•©
Pi â† ((0=â‰¡) âŠ‘âˆ˜âŠ¢âŸâŠ£ {ğ•© LargePiâˆ˜âŠ£Â¨âŒ¾((next<ğ•©)âŠ¸/) primesâ‹ğ•©}âŒ¾â¥Š)âˆ˜âŒŠâš‡1
LargePi â† {
  # Meissel-Lehmer algorithm
  Extend 2Ã—âˆšğ•©  # Need one past âˆšğ•©
  aâ€¿bâ€¿c â† primes â‹ 4â€¿2â€¿3 âˆš ğ•©

  ph â† -Â´ +Â´Â¨ 2âŒŠâˆ˜Ã·Ëœ1+ (â†“â¥Šğ•©) (âŠ¢âˆ¾âŸœ(0âŠ¸<âŠ¸/)Â¨Â·âŒ½âŒŠâˆ˜Ã·Ëœ)Â´ 1â†“aâ†‘primes  # Ï†(ğ•©,a)

  p â† aâ†“bâ†‘primes
  w â† ğ•© Ã· p
  v â† w â†‘Ëœ caâ†c-a
  j â† (primes â‹ âˆšv) - a+â†•ca
  r â† +Â´Pi w âˆ¾ (j/v)Ã·(âŠ’âŠ¸+/j)âŠp
  is â† (b+a-2) Ã— (bÂ¬a) Ã· 2
  js â† +Â´ j Ã— (a+â†•â‰ j)+(j-1)Ã·2
  ph + is + js - r
}

IsPrime â† {
  CheckNat ğ•©
  nextâŠ¸â‰¤â—¶âŸ¨âŠ‘âˆŠâŸœprimes, âˆ§Â´0â‰ PrimesToâˆ˜âˆšâŠ¸|âŸ© ğ•©
}âš‡0

Factor â† {
  CheckNat ğ•©
  âˆ§ ğ•© {(0<â‰ âˆ˜âŠ¢)â—¶âŸ¨â¥ŠâŠ£,âŠ¢âˆ¾ğ•ŠâŸ©âŸ(>âŸœ1)ËœâŸœ(ğ•¨Ã·Ã—Â´)ğ•©/Ëœ0=ğ•©|ğ•¨} PrimesTo âˆšğ•©
}âš‡0

# Prime factors and exponents
FactorExponents â† (/â‰ âŸœÂ«)âŠ¸(âŠ â‰ -âŸœ(Â¯1âŠ¸Â»)âˆ˜âŠ£) âˆ˜ Factor âš‡0

# Numbers of prime factors (with multiplicity) for â†•ğ•©
FactorCounts â† {
  Â¯1âŒ¾âŠ‘ +Â´ ğ•©{ğ•—â¥Š0(1+âŒ¾âŠ‘âŠ¢âŒœ)âŸ(âŒŠğ•©â‹†â¼ğ•—)Ëœâ†•ğ•©}Â¨ PrimesTo ğ•©
}

# Euler's Totient function
Totient â† (Ã—Â´ (-âŸœ1 Ã— âŠ£â‹†âŠ¢-1Ë™)Ë)âˆ˜FactorExponentsâš‡0
