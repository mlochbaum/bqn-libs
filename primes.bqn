âŸ¨
  PrimesTo
  PrimesIn, SieveSegment
  NextPrime, PrevPrime
  IsPrime
  Pi
  NthPrime
  Factor, FactorExponents
  FactorCounts
  Totient
âŸ©â‡

# Wheel factorization
MakeWheel â† {
  len â‡ Ã—Â´primes â‡ ğ•©     # Primes in wheel and wheel length
  mask â‡ âˆ§Â´(lenâ¥Š0<â†•)Â¨primes
  numc â‡ â‰  coprime â‡ /mask

  # Get prime mask on segment [start,end) with prime divisors pd
  # Assumes pd doesn't intersect primes, or [start,end)
  Sieve â‡ {pd ğ•Š startâ€¿end:
    wâ†coprime,wnâ†numc,wlâ†len
    bcâ€¿ep â† wl (âŒŠâˆ˜Ã·Ëœ â‹ˆ wâ‹|) (ğ•©-1)Ã·âŒœpd

    # Do first partial wheels together
    m â† â‰ Ëbc
    Uâ†{âŸ¨râ†ğ•©-ğ•¨,(âŠ’/r)+r/ğ•¨âŸ©} #{âŸ¨râ†ğ•©-ğ•¨,((â†•Â·âŠ‘Â¯1âŠ¸â†‘)+r/ğ•¨-Â»)+`râŸ©}
    frâ€¿fk â† UâŸœ((mÃ—wn)âŠ¸âŒˆ)Ë ep
    j â† (fr/pd) Ã— (fr/wlÃ—âŠbc) + fkâŠw

    # Then the remainder for each prime spanning multiple wheels
    Rem â† {pâ€¿sâ€¿eâ€¿o: # prime, start, end, overflow
      plâ†pÃ—wl â‹„ pwâ†start-ËœpÃ—w
      âŸ¨â¥Š(plÃ—s+â†•e-s)+âŒœpw, (plÃ—e)+oâ†‘pwâŸ©
    }
    b â† RemË˜ â‰>mâŠ¸/Â¨âŸ¨pd,1+âŠbc,1âŠbc,1âŠepâŸ©

    i â† âˆ¾ âŸ¨j-startâŸ©âˆ¾â¥Šb
    0Â¨âŒ¾(iâŠ¸âŠ) (end-start)â¥ŠstartâŒ½mask
  }
}

# Prime state
next â† 11
âŸ¨SieveâŸ© â† wheel â† MakeWheel 2â€¿3â€¿5â€¿7
wlen â† â‰  wheel.primes
primes â† wheel.primes
Extend â† {
  E â† {
    next â†© âŒˆ ğ•© âŒŠ ((2â‹†24)âŠ¸+ âŒŠ Ã—Ëœ) oldâ†next
    primes âˆ¾â†© old + / (wlenâ†“primes(â‹â†‘âŠ£)âˆšnext) Sieve oldâ€¿next
    ğ•ŠâŸ(nextâŠ¸<) ğ•©
  }
  next Eâˆ˜(2âŠ¸Ã—âŠ¸âŒˆ)âŸ< ğ•©
}

CheckNum  â† "Argument must be a non-negative number" ! (1=â€¢Type)â—¶âŸ¨0,0âŠ¸â‰¤âŸ©
CheckNat  â† "Argument must be a natural number" ! (1=â€¢Type)â—¶âŸ¨0,|âˆ˜âŒŠâŠ¸=âŸ©

PrimesTo â† {
  CheckNum ğ•©
  Extend ğ•©
  primes (â‹â†‘âŠ£) ğ•©
}

_getSegment â† {ind _ğ•£:
  PRange â† { primes (âŠ£âŠËœÂ·(âŠ£+â†•âˆ˜-Ëœ)Â´â‹) ğ•©-1 }
  sn â† {âŠ‘âˆ˜âŠ¢+/âˆ˜ğ•}âŸğ•— sieve
  pr â† {-ËœÂ´ â†‘ Â·/â¼ğ•-âŠ‘}âŸ(Â¬ğ•—) prange
  S â† {pd ğ•Š sâ€¿e:
    n â† nextâŒŠe
    (PR sâ€¿n) âˆ¾ <Â´â—¶âŸ¨âŸ¨âŸ©,primesâŠ¸SNâŸ© nâ€¿e
  }
  # IsPrimeÂ¨âŠ¸(ğ•—â—¶âŠ£â€¿/) start(âŠ£+â†•âˆ˜-Ëœ)end
  {ğ•Š startâ€¿end:
    CheckNatÂ¨ ğ•©
    "Range must be ordered" ! â‰¤Â´ğ•©
    (wlen â†“ PrimesTo âˆšend-1) (nextâ‰¤start)â—¶Sâ€¿SN ğ•©
  }
}
SieveSegment â† 0 _getSegment  # IsPrimeÂ¨   (âŠ£+â†•âˆ˜-Ëœ)Â´
PrimesIn     â† 1 _getSegment  # IsPrimeÂ¨âŠ¸/ (âŠ£+â†•âˆ˜-Ëœ)Â´

NextPrime â† {        (0<â‰ )â—¶âŸ¨ğ•Š1âŠ‘R,  âŠ‘ âŸ© PrimesIn râ†  ğ•©+1â€¿65 }âš‡0
PrevPrime â† { !2<ğ•© â‹„ (0<â‰ )â—¶âŸ¨ğ•Š0âŠ‘R,Â¯1âŠ‘âŠ¢âŸ© PrimesIn râ†1âŒˆğ•©-64â€¿0 }âš‡0

IsPrime â† {
  CheckNat ğ•©
  p â† wheel.primes
  c â† 0=p|ğ•©
  (âˆ¨Â´c)â—¶âŸ¨(Ã—ËœÂ¯1âŠ‘p)âŠ¸<â—¶âŸ¨1âŠ¸â‰ ,MillerRabinâŸ©, câŠ‘âˆ˜/âŸœpâŠ¸=âŠ¢ âŸ© ğ•©
}âš‡0

# Compute n|ğ•¨Ã—ğ•© in high precision
_modMul â† { n _ğ•£:
  # Split each argument into two 26-bit numbers, with the remaining
  # mantissa bit encoded in the sign of the lower-order part.
  qâ†1+2â‹†27
  Split â† { hâ†(qÃ—ğ•©)(âŠ£--)ğ•© â‹„ âŸ¨ğ•©-h,hâŸ© }
  # The product, and an error relative to precise split multiplication.
  Mul â† Ã— (âŠ£ â‹ˆ -âŠ¸(+Â´)) Â·â¥ŠÃ—âŒœâ—‹Split
  ((nÃ—<âŸœ0)âŠ¸+ -âŸœn+âŠ¢)Â´ n | Mul
}
MillerRabin â† { ğ•Š n:
  # n = 1 + dÃ—2â‹†s
  s â† 0 {ğ•¨ 2âŠ¸|â—¶âŸ¨+âŸœ1ğ•Š2âŒŠâˆ˜Ã·ËœâŠ¢,âŠ£âŸ© ğ•©} n-1
  d â† (n-1) Ã· 2â‹†s

  # Arithmetic mod n
  Mul â† n _modMul
  Pow â† Mul{ğ”½Â´ğ”½ËœâŸ(/2|âŒŠâˆ˜Ã·âŸœ2âŸ(â†•1+Â·âŒŠ2â‹†â¼âŠ¢)ğ•©)ğ•¨}

  # Miller-Rabin test
  MR â† {
       1 =ğ•© ? ğ•¨â‰ s ;
    (n-1)=ğ•© ? 0   ;
        ğ•¨â‰¤1 ? 1   ;
    (ğ•¨-1) ğ•Š MulËœğ•©
  }
  C â† { ğ•Ša: s MR a Pow d }  # Is composite
  0 {ğ•¨<âŸœâ‰ â—¶âŸ¨1,Câˆ˜âŠ‘â—¶âŸ¨+âŸœ1âŠ¸ğ•Š,0âŸ©âŸ©ğ•©} Witnesses ğ•©
}

witnesses â† { (1â†“ğ•¨)âŠ¸â‹âŒ¾< âŠ‘ ğ•©Ë™ }Ë â‰âˆ˜â€¿2â¥Š âŸ¨
  0                , âŸ¨1948244569546278âŸ©
  212321           , 15â€¿5511855321103177
  624732421        , 15â€¿7363882082â€¿992620450144556
  273919523041     , 2â€¿2570940â€¿211991001â€¿3749873356
  47636622961201   , 2â€¿2570940â€¿880937â€¿610386380â€¿4130785767
  3770579582154547 , 2â€¿325â€¿9375â€¿28178â€¿450775â€¿9780504â€¿1795265022
âŸ©

# Number of primes less than or equal to ğ•©
Pi â† ((0=â‰¡) âŠ‘âˆ˜âŠ¢âŸâŠ£ {ğ•© LargePiâˆ˜âŠ£Â¨âŒ¾((next<ğ•©)âŠ¸/) primesâ‹ğ•©}âŒ¾â¥Š)âˆ˜âŒŠâš‡1
LargePi â† {
  # Meissel-Lehmer algorithm
  Extend 2Ã—âˆšğ•©  # Need one past âˆšğ•©
  aâ€¿bâ€¿c â† primes â‹ 4â€¿2â€¿3 âˆš ğ•©

  ph â† -Â´ +Â´Â¨ 2âŒŠâˆ˜Ã·Ëœ1+ (â†“â¥Šğ•©) (âŠ¢âˆ¾âŸœ(0âŠ¸<âŠ¸/)Â¨Â·âŒ½âŒŠâˆ˜Ã·Ëœ)Â´ 1â†“aâ†‘primes  # Ï†(ğ•©,a)

  p â† aâ†“bâ†‘primes
  w â† ğ•© Ã· p
  v â† w â†‘Ëœ caâ†c-a
  j â† (primes â‹ âˆšv) - a+â†•ca
  r â† +Â´Pi w âˆ¾ (j/v)Ã·(âŠ’âŠ¸+/j)âŠp
  is â† (b+a-2) Ã— (bÂ¬a) Ã· 2
  js â† +Â´ j Ã— (a+â†•â‰ j)+(j-1)Ã·2
  ph + is + js - r
}

NthPrime â† {primesâ‰ âŠ¸â‰¤â—¶âŸ¨âŠ‘Ëœ,NPâŸ©ğ•©}âš‡0
NP â† {
  a â† 2âŒˆâŒˆ (1-Ëœâ‹†â¼âŸ2(++-âŸœ2âŠ¸Ã·)â‹†â¼)âŠ¸Ã— ğ•© # Approximation
  d â† ğ•© - Pi a-1                   # Primes remaining
  p â† â‹†â¼a                          # Numberâ†’distance multiplier
  e â† 8Ã—Ã—d-0.5                     # Go a few primes further
  a { ğ•© (â‰¥âŸœ-âˆ§<)âŸœâ‰ â—¶âŸ¨nğ•ŠâŠ£-Ã—âŠ¸Ã—âŸœâ‰ ,âŠ‘âŸ© PrimesIn âˆ§ğ•¨â‹ˆnâ†ğ•¨+âŒŠpÃ—ğ•©+e } d
}

# Prime factors and exponents
FactorExponents â† {
  CheckNat ğ•©
  2âŠ¸âŒŠâ—¶âŸ¨!âˆ˜"Can't factor 0", 2â€¿0âŠ¸â¥Š, IsPrimeâ—¶âŸ¨FactorTrial, â‰Ë˜â‹ˆâŸœ1âŸ©âŸ© ğ•©
}âš‡0
FactorTrial â† { ğ•Šn:
  r â† 0â€¿2â¥Š0  # Transposed result
  Div â† {ğ•Šp: # Add exponents of p to result
    Dâ†0=p|âŠ¢
    eâ†0 â‹„ nâ†©{e+â†©1â‹„ğ•ŠâŸDğ•©Ã·p}n
    râˆ¾â†©pâ€¿e
  }
  Try â† {
    ğ•© âŒŠâ†© 1+âŒŠâˆšn
    ğ•¨<ğ•© ?
    DivÂ¨ (0=|âŸœn)âŠ¸/ PrimesIn ğ•¨â€¿ğ•©
    {râˆ¾â†©â‰PollardFactors nâ‹„nâ†©1â‹„ğ•©}âŸÂ¬ ğ•©<pollardThreshold ?
    ğ•© ğ•Š 2Ã—ğ•©
  ;@}
  2 Try 64
  â‰ r âˆ¾ (1<n)/â‰nâ€¿1
}

# Pollard's rho algorithm
# https://maths-people.anu.edu.au/~brent/pub/pub051.html
pollardThreshold â† 2â‹†16
_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
GCD â† {ğ•¨(|ğ•ŠâŸ(>âŸœ0)âŠ£)ğ•©}
# Return a divisor of n other than 1. Can be n if the algorithm fails.
# c should be in â†•n but not 0 or n-2.
PollardRho â† { c ğ•Š n:
  xâ†ysâ†y â† 2
  q â† 1
  Mul â† n _modMul
  Adv â† {n-ËœâŸâ‰¤c+MulËœğ•©}
  NextY â† {ğ•¤â‹„ |x-(y Advâ†©)}
  g â† { ğ•Š r:
    x â†© y
    y AdvâŸrâ†©
    k â† 0
    m â† 100  # Check GCD to see if we can stop every m iterations
    FindG â† {ğ•¤
      k0 â† k
      k â†© r âŒŠ k+m
      ys â†© y
      q MulâŸœNextYâŸ(k-k0)â†©
      n GCD q
    } _while_ {k<r? 1=ğ•©; 0}
    ğ•Šâˆ˜(rÃ—2)âŸ(1âŠ¸=) FindG 1
  } 1
  y â†© ys  # Backtrack if n=g
  (n GCD NextY)_while_(1âŠ¸=)âˆ˜1âŸ(nâŠ¸=) g
}
Exps â† (/â‰ âŸœÂ«)âŠ¸(âŠ â‰ -âŸœ(Â¯1âŠ¸Â»)âˆ˜âŠ£)âˆ˜âˆ§  # Exponents from list of factors
PollardFactors â† Exps âˆ˜ { ğ•Š n:
  pollardThreshold<n ? Â¬IsPrime n ?
  gâ†n â‹„ 1âŠ¸+ _while_ {n=gâ†©ğ•© PollardRho n} 1
  g âˆ¾â—‹ğ•Š nÃ·g
; â‰ğ•©
}

# Prime factors with repetition
Factor â† /ËœËâˆ˜FactorExponentsâš‡0

# Numbers of prime factors (with multiplicity) for â†•ğ•©
FactorCounts â† {
  Â¯1âŒ¾âŠ‘ +Â´ ğ•©{ğ•—â¥Š0(1+âŒ¾âŠ‘âŠ¢âŒœ)âŸ(âŒŠğ•©â‹†â¼ğ•—)Ëœâ†•ğ•©}Â¨ PrimesTo ğ•©
}

# Euler's Totient function
Totient â† (Ã—Â´ (-âŸœ1 Ã— âŠ£â‹†âŠ¢-1Ë™)Ë)âˆ˜FactorExponentsâš‡0
