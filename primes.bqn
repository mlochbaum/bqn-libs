âŸ¨
  PrimesTo
  PrimesIn, SieveSegment
  NextPrime, PrevPrime
  IsPrime
  Pi
  NthPrime
  Factor, FactorExponents
  FactorCounts
  Totient
âŸ©â‡

# Wheel factorization
MakeWheel â† {
  len â‡ Ã—Â´primes â‡ ğ•©     # Primes in wheel and wheel length
  mask â‡ âˆ§Â´(lenâ¥Š0<â†•)Â¨primes
  numc â‡ â‰  coprime â‡ /mask

  # Get prime mask on segment [start,end) with prime divisors pd
  # Assumes pd doesn't intersect primes, or [start,end)
  Sieve â‡ {pd ğ•Š startâ€¿end:
    wâ†coprime,wnâ†numc,wlâ†len
    bcâ€¿ep â† wl (âŒŠâˆ˜Ã·Ëœ â‰â—‹< wâ‹|) (ğ•©-1)Ã·âŒœpd

    # Do first partial wheels together
    m â† â‰ Ëbc
    Uâ†{âŸ¨râ†ğ•©-ğ•¨,(âŠ’/r)+r/ğ•¨âŸ©} #{âŸ¨râ†ğ•©-ğ•¨,((â†•Â·âŠ‘Â¯1âŠ¸â†‘)+r/ğ•¨-Â»)+`râŸ©}
    frâ€¿fk â† UâŸœ((mÃ—wn)âŠ¸âŒˆ)Ë ep
    j â† (fr/pd) Ã— (fr/wlÃ—âŠbc) + fkâŠw

    # Then the remainder for each prime spanning multiple wheels
    Rem â† {pâ€¿sâ€¿eâ€¿o: # prime, start, end, overflow
      plâ†pÃ—wl â‹„ pwâ†start-ËœpÃ—w
      âŸ¨â¥Š(plÃ—s+â†•e-s)+âŒœpw, (plÃ—e)+oâ†‘pwâŸ©
    }
    b â† RemË˜ â‰>mâŠ¸/Â¨âŸ¨pd,1+âŠbc,1âŠbc,1âŠepâŸ©

    i â† âˆ¾ âŸ¨j-startâŸ©âˆ¾â¥Šb
    0Â¨âŒ¾(iâŠ¸âŠ) (end-start)â¥ŠstartâŒ½mask
  }
}

# Prime state
next â† 11
âŸ¨SieveâŸ© â† wheel â† MakeWheel 2â€¿3â€¿5â€¿7
wlen â† â‰  wheel.primes
primes â† wheel.primes
Extend â† {
  E â† {
    next â†© âŒˆ ğ•© âŒŠ ((2â‹†22)âŠ¸+ âŒŠ Ã—Ëœ) oldâ†next
    primes âˆ¾â†© old + / (wlenâ†“primes(â‹â†‘âŠ£)âˆšnext) Sieve oldâ€¿next
    ğ•ŠâŸ(nextâŠ¸<) ğ•©
  }
  next Eâˆ˜(2âŠ¸Ã—âŠ¸âŒˆ)âŸ< ğ•©
}

CheckNum  â† "Argument must be a non-negative number" ! (1=â€¢Type)â—¶âŸ¨0,0âŠ¸â‰¤âŸ©
CheckNat  â† "Argument must be a natural number" ! (1=â€¢Type)â—¶âŸ¨0,|âˆ˜âŒŠâŠ¸=âŸ©

PrimesTo â† {
  CheckNum ğ•©
  Extend ğ•©
  primes (â‹â†‘âŠ£) ğ•©
}

_getSegment â† {ind _ğ•£:
  PRange â† { primes (âŠ£âŠËœÂ·(âŠ£+â†•âˆ˜-Ëœ)Â´â‹) ğ•©-1 }
  sn â† {âŠ‘âˆ˜âŠ¢+/âˆ˜ğ•}âŸğ•— sieve
  pr â† {-ËœÂ´ â†‘ Â·/â¼ğ•-âŠ‘}âŸ(Â¬ğ•—) prange
  S â† {pd ğ•Š sâ€¿e:
    n â† nextâŒŠe
    (PR sâ€¿n) âˆ¾ <Â´â—¶âŸ¨âŸ¨âŸ©,primesâŠ¸SNâŸ© nâ€¿e
  }
  # IsPrimeÂ¨âŠ¸(ğ•—â—¶âŠ£â€¿/) start(âŠ£+â†•âˆ˜-Ëœ)end
  {ğ•Š startâ€¿end:
    CheckNatÂ¨ ğ•©
    "Range must be ordered" ! â‰¤Â´ğ•©
    (wlen â†“ PrimesTo âˆšend-1) (nextâ‰¤start)â—¶Sâ€¿SN ğ•©
  }
}
SieveSegment â† 0 _getSegment  # IsPrimeÂ¨   (âŠ£+â†•âˆ˜-Ëœ)Â´
PrimesIn     â† 1 _getSegment  # IsPrimeÂ¨âŠ¸/ (âŠ£+â†•âˆ˜-Ëœ)Â´

NextPrime â† {        (0<â‰ )â—¶âŸ¨ğ•Š1âŠ‘R,  âŠ‘ âŸ© PrimesIn râ†  ğ•©+1â€¿65 }âš‡0
PrevPrime â† { !2<ğ•© â‹„ (0<â‰ )â—¶âŸ¨ğ•Š0âŠ‘R,Â¯1âŠ‘âŠ¢âŸ© PrimesIn râ†1âŒˆğ•©-64â€¿0 }âš‡0

IsPrime â† {
  CheckNat ğ•©
  p â† wheel.primes
  c â† âˆ¨Â´0=p|ğ•©
  câ—¶âŸ¨(Ã—ËœÂ¯1âŠ‘p)âŠ¸<â—¶1â€¿MillerRabin, 0âŸ© ğ•©
}âš‡0

MillerRabin â† { ğ•Š n:
  # n = 1 + dÃ—2â‹†s
  s â† 0 {ğ•¨ 2âŠ¸|â—¶âŸ¨+âŸœ1ğ•Š2âŒŠâˆ˜Ã·ËœâŠ¢,âŠ£âŸ© ğ•©} n-1
  d â† (n-1) Ã· 2â‹†s

  # Arithmetic mod n
  qâ†2â‹†27  # Half a double mantissa, rounded up
  Mul â† {ağ•Šb:
    ahâ€¿bhâ†ab-alâ€¿blâ†q|abâ†aâ€¿b
    bmâ†2|bl  # Avoid 27Ã—27 bits
    ((nÃ—<âŸœ0)âŠ¸+ -âŸœn+âŠ¢)Â´ n | (aÃ—bm) âˆ¾ â¥Šahâ€¿alÃ—âŒœbhâ€¿(bl-bm)
  }
  Pow â† (1<âŠ¢)â—¶âŸ¨â‹†,Mul{ğ”½Â´ğ”½ËœâŸ(/2|âŒŠâˆ˜Ã·âŸœ2âŸ(â†•Â·âŒˆ2â‹†â¼âŠ¢)ğ•©)ğ•¨}âŸ©

  # Miller-Rabin test
  mr â† {(âŠ‘ğ•¨)â—¶âŸ¨ğ•©,1âŠ‘ğ•¨âŸ©}Â´ âŸ¨
    âŸ¨   1 âŠ¸=  â‹„ â‰ âŸœs âŸ©
    âŸ¨(n-1)âŠ¸=  â‹„ 0   âŸ©
    âŸ¨    â‰¤âŸœ1  â‹„ 1   âŸ©
    {(ğ•¨-1) MR MulËœğ•©}
  âŸ©
  C â† { ğ•Ša: s MR a Pow d }  # Is composite
  0 {ğ•¨<âŸœâ‰ â—¶âŸ¨1,Câˆ˜âŠ‘â—¶âŸ¨+âŸœ1âŠ¸ğ•Š,0âŸ©âŸ©ğ•©} Witnesses ğ•©
}

witnesses â† { (1â†“ğ•¨)âŠ¸â‹âŒ¾< âŠ‘ ğ•©Ë™ }Ë â‰âˆ˜â€¿2â¥Š âŸ¨
  0                , âŸ¨1948244569546278âŸ©
  212321           , 15â€¿5511855321103177
  624732421        , 15â€¿7363882082â€¿992620450144556
  273919523041     , 2â€¿2570940â€¿211991001â€¿3749873356
  47636622961201   , 2â€¿2570940â€¿880937â€¿610386380â€¿4130785767
  3770579582154547 , 2â€¿325â€¿9375â€¿28178â€¿450775â€¿9780504â€¿1795265022
âŸ©

# Number of primes less than or equal to ğ•©
Pi â† ((0=â‰¡) âŠ‘âˆ˜âŠ¢âŸâŠ£ {ğ•© LargePiâˆ˜âŠ£Â¨âŒ¾((next<ğ•©)âŠ¸/) primesâ‹ğ•©}âŒ¾â¥Š)âˆ˜âŒŠâš‡1
LargePi â† {
  # Meissel-Lehmer algorithm
  Extend 2Ã—âˆšğ•©  # Need one past âˆšğ•©
  aâ€¿bâ€¿c â† primes â‹ 4â€¿2â€¿3 âˆš ğ•©

  ph â† -Â´ +Â´Â¨ 2âŒŠâˆ˜Ã·Ëœ1+ (â†“â¥Šğ•©) (âŠ¢âˆ¾âŸœ(0âŠ¸<âŠ¸/)Â¨Â·âŒ½âŒŠâˆ˜Ã·Ëœ)Â´ 1â†“aâ†‘primes  # Ï†(ğ•©,a)

  p â† aâ†“bâ†‘primes
  w â† ğ•© Ã· p
  v â† w â†‘Ëœ caâ†c-a
  j â† (primes â‹ âˆšv) - a+â†•ca
  r â† +Â´Pi w âˆ¾ (j/v)Ã·(âŠ’âŠ¸+/j)âŠp
  is â† (b+a-2) Ã— (bÂ¬a) Ã· 2
  js â† +Â´ j Ã— (a+â†•â‰ j)+(j-1)Ã·2
  ph + is + js - r
}

NthPrime â† {primesâ‰ âŠ¸â‰¤â—¶âŸ¨âŠ‘Ëœ,NPâŸ©ğ•©}âš‡0
NP â† {
  a â† 2âŒˆâŒˆ (1-Ëœâ‹†â¼âŸ2(++-âŸœ2âŠ¸Ã·)â‹†â¼)âŠ¸Ã— ğ•© # Approximation
  d â† ğ•© - Pi a-1                   # Primes remaining
  p â† â‹†â¼a                          # Numberâ†’distance multiplier
  e â† 8Ã—Ã—d-0.5                     # Go a few primes further
  a { ğ•© (â‰¥âŸœ-âˆ§<)âŸœâ‰ â—¶âŸ¨nğ•ŠâŠ£-Ã—âŠ¸Ã—âŸœâ‰ ,âŠ‘âŸ© PrimesIn âˆ§ğ•¨â‰nâ†ğ•¨+âŒŠpÃ—ğ•©+e } d
}

# Prime factors and exponents
FactorExponents â† {
  CheckNat ğ•©
  2âŠ¸âŒŠâ—¶âŸ¨!âˆ˜"Can't factor 0", 2â€¿0âŠ¸â¥Š, IsPrimeâ—¶âŸ¨FactorTrial, â‰Ë˜â‰âŸœ1âŸ©âŸ© ğ•©
}âš‡0
FactorTrial â† { ğ•Šn:
  r â† 0â€¿2â¥Š0  # Transposed result
  Div â† {ğ•Šp: # Add exponents of p to result
    Dâ†0=p|âŠ¢
    eâ†0 â‹„ nâ†©{e+â†©1â‹„ğ•ŠâŸDğ•©Ã·p}n
    râˆ¾â†©pâ€¿e
  }
  Try â† {
    DivÂ¨ (0=|âŸœn)âŠ¸/ PrimesIn ğ•¨â€¿ğ•©
    ğ•© Try (1+âŒŠâˆšn)âŒŠ2Ã—ğ•©
  }âŸ<
  2 Try (1+âŒŠâˆšn)âŒŠ64
  â‰ r âˆ¾ (1<n)/â‰nâ€¿1
}

# Prime factors with repetition
Factor â† /ËœËâˆ˜FactorExponentsâš‡0

# Numbers of prime factors (with multiplicity) for â†•ğ•©
FactorCounts â† {
  Â¯1âŒ¾âŠ‘ +Â´ ğ•©{ğ•—â¥Š0(1+âŒ¾âŠ‘âŠ¢âŒœ)âŸ(âŒŠğ•©â‹†â¼ğ•—)Ëœâ†•ğ•©}Â¨ PrimesTo ğ•©
}

# Euler's Totient function
Totient â† (Ã—Â´ (-âŸœ1 Ã— âŠ£â‹†âŠ¢-1Ë™)Ë)âˆ˜FactorExponentsâš‡0
