âŸ¨
  PrimesTo
  PrimesIn, SieveSegment
  IsPrime
  Factor, FactorExponents
  FactorCounts
âŸ©â‡

# Wheel factorization
MakeWheel â† {
  len â‡ Ã—Â´primes â‡ ğ•©     # Primes in wheel and wheel length
  mask â‡ âˆ§Ë0â‰ primes|âŒœâ†•len
  numc â‡ â‰  coprime â‡ /mask

  # Get prime mask on segment [start,end) with prime divisors pd
  # Assumes pd doesn't intersect primes, or [start,end)
  Sieve â‡ {pd ğ•Š startâ€¿end:
    wâ†coprime,wnâ†numc,wlâ†len
    bcâ€¿ep â† wl (âŒŠâˆ˜Ã·Ëœ â‰â—‹< wâ‹|) (ğ•©-1)Ã·âŒœpd

    # Do first partial wheels together
    m â† â‰ Ëbc
    Uâ†{âŸ¨râ†ğ•©-ğ•¨,(âŠ’/r)+r/ğ•¨âŸ©} #{âŸ¨râ†ğ•©-ğ•¨,((â†•Â·âŠ‘Â¯1âŠ¸â†‘)+r/ğ•¨-Â»)+`râŸ©}
    frâ€¿fk â† UâŸœ((mÃ—wn)âŠ¸âŒˆ)Ë ep
    j â† (fr/pd) Ã— (fr/wlÃ—âŠbc) + fkâŠw

    # Then the remainder for each prime spanning multiple wheels
    Rem â† {pâ€¿sâ€¿eâ€¿o: # prime, start, end, overflow
      plâ†pÃ—wl â‹„ pwâ†start-ËœpÃ—w
      âŸ¨â¥Š(plÃ—s+â†•e-s)+âŒœpw, (plÃ—e)+oâ†‘pwâŸ©
    }
    b â† RemË˜ â‰>mâŠ¸/Â¨âŸ¨pd,1+âŠbc,1âŠbc,1âŠepâŸ©

    i â† âˆ¾ âŸ¨j-startâŸ©âˆ¾â¥Šb
    0Â¨âŒ¾(iâŠ¸âŠ) (end-start)â¥ŠstartâŒ½mask
  }
}

# Prime state
next â† 11
âŸ¨SieveâŸ© â† wheel â† MakeWheel 2â€¿3â€¿5â€¿7
wlen â† â‰  wheel.primes
primes â† wheel.primes
Extend â† {
  E â† {
    next â†© âŒˆ ğ•© âŒŠ ((2â‹†24)âŠ¸+ âŒŠ Ã—Ëœ) oldâ†next
    primes âˆ¾â†© old + / (wlenâ†“primes(â‹â†‘âŠ£)âˆšnext) Sieve oldâ€¿next
    ğ•ŠâŸ(nextâŠ¸<) ğ•©
  }
  next Eâˆ˜(2âŠ¸Ã—âŠ¸âŒˆ)âŸ< ğ•©
}

CheckNum  â† "Argument must be a non-negative number" ! (1=â€¢Type)â—¶âŸ¨0,0âŠ¸â‰¤âŸ©
CheckNat  â† "Argument must be a natural number" ! (1=â€¢Type)â—¶âŸ¨0,|âˆ˜âŒŠâŠ¸=âŸ©

PrimesTo â† {
  CheckNum ğ•©
  Extend ğ•©
  primes (â‹â†‘âŠ£) ğ•©
}

_getSegment â† {ind _ğ•£:
  PRange â† { primes (âŠ£âŠËœÂ·(âŠ£+â†•âˆ˜-Ëœ)Â´â‹) ğ•©-1 }
  sn â† {âŠ‘âˆ˜âŠ¢+/âˆ˜ğ•}âŸğ•— sieve
  pr â† {-ËœÂ´ â†‘ Â·/â¼ğ•-âŠ‘}âŸ(Â¬ğ•—) prange
  S â† {ğ•Š sâ€¿e:
    n â† nextâŒŠe
    (PR sâ€¿n) âˆ¾ <Â´â—¶âŸ¨âŸ©â€¿SN nâ€¿e
  }
  # IsPrimeÂ¨âŠ¸(ğ•—â—¶âŠ£â€¿/) start(âŠ£+â†•âˆ˜-Ëœ)end
  {ğ•Š startâ€¿end:
    CheckNatÂ¨ ğ•©
    "Range must be ordered" ! â‰¤Â´ğ•©
    (wlen â†“ PrimesTo âˆšend-1) (nextâ‰¤start)â—¶Sâ€¿SN ğ•©
  }
}
SieveSegment â† 0 _getSegment  # IsPrimeÂ¨   (âŠ£+â†•âˆ˜-Ëœ)Â´
PrimesIn     â† 1 _getSegment  # IsPrimeÂ¨âŠ¸/ (âŠ£+â†•âˆ˜-Ëœ)Â´

IsPrime â† {
  CheckNat ğ•©
  nextâŠ¸â‰¤â—¶âŸ¨âŠ‘âˆŠâŸœprimes, âˆ§Â´0â‰ PrimesToâˆ˜âˆšâŠ¸|âŸ© ğ•©
}âš‡0

Factor â† {
  CheckNat ğ•©
  âˆ§ ğ•© {(0<â‰ âˆ˜âŠ¢)â—¶âŸ¨â¥ŠâŠ£,âŠ¢âˆ¾ğ•ŠâŸ©âŸ(>âŸœ1)ËœâŸœ(ğ•¨Ã·Ã—Â´)ğ•©/Ëœ0=ğ•©|ğ•¨} PrimesTo âˆšğ•©
}âš‡0

# Prime factors and exponents
FactorExponents â† (/â‰ âŸœÂ«)âŠ¸(âŠ â‰ -âŸœ(Â¯1âŠ¸Â»)âˆ˜âŠ£) âˆ˜ Factor âš‡0

# Numbers of prime factors (with multiplicity) for â†•ğ•©
FactorCounts â† {
  Â¯1âŒ¾âŠ‘ +Â´ ğ•©{ğ•—â¥Š0(1+âŒ¾âŠ‘âŠ¢âŒœ)âŸ(âŒŠğ•©â‹†â¼ğ•—)Ëœâ†•ğ•©}Â¨ PrimesTo ğ•©
}
