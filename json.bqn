# JSON: JavaScript Object Notation
âŸ¨
  Parse  # JSON string to BQN
âŸ©â‡

# JSON numbers, strings, and lists correspond directly to BQN
# Objects are represented as keysâ‰values
# true, false, null are represented as <"true", <"false", <"null"

âŸ¨ConstsâŸ© â† {
  val â† <Â¨ name â† "true"â€¿"false"â€¿"null"
  Consts â‡ {
    i â† name âŠ ğ•©
    "Unknown constant" ! âˆ§Â´ i<â‰ name
    i âŠ val
  }
}
âŸ¨UnEscapeâŸ© â† {
  in â† """\/bfrnt"
  out â† (3â†‘in)âˆ¾@+8â€¿12â€¿13â€¿10â€¿9
  diff â† (out-in) âˆ¾ 0
  Basic â† {
    i â† in âŠ ğ•©
    "Unknown escape" ! âˆ§Â´ğ•¨â‰¤i<â‰ in
    ğ•© + ğ•¨ Ã— i âŠ diff
  }

  hc â† "0Aa"
  hb â† â¥Šhc+0â‰Ë˜10â€¿6â€¿6   # Hex boundaries, start and after-end
  ho â† 2/hc-0â€¿10â€¿10    # Corresponding offsets
  Hex â† { u ğ•Š ğ•©:
    d â† ğ•© /Ëœ m â† â‰ ` (4â¥Š0)âŠ¸Â»âŠ¸â‰  Â»u
    t â† hb â‹ d
    "String \u must be followed by 4 hex characters" ! âˆ§Â´1=2|t
    # Now m can't run past the end or self-intersect,
    # or it would have hit a closing quote or backslash
    v â† 16âŠ¸Ã—âŠ¸+ËœËâŒ½ â‰âˆ˜â€¿4â¥Š d-tâŠho
    âŸ¨(v+@-'u')âŠ¸+âŒ¾(uâŠ¸/)ğ•©, mâŸ©
  }

  UnEscape â‡ { e ğ•Š ğ•©:
    u â† e âˆ§ ğ•©='u'
    (u<e)âŠ¸BasicâŒ¾âŠ‘ u HexâŸœâŠ‘âŸ(âˆ¨Â´u) ğ•©â€¿0
  }
}

# JSON to âŸ¨tokens, constants, numbers, stringsâŸ©
# Tokens are characters {}[],: and a constant, 0 number, " string
# Values correspond to a, 0, and " in order
Tokenize â† {
  # Strings
  e â† Â»eo â† <`'\'=ğ•©
  s â† â‰ `q â† e<'"'=ğ•©
  "Unclosed quote" ! Â¬Â¯1âŠ‘s
  "Backslash outside string" ! âˆ§Â´sâ‰¥e
  xeâ€¿dr â† e UnEscape ğ•©              # Escaped ğ•©; characters to drop
  sg â† ((1-Ëœ(s>qâˆ¨eoâˆ¨dr)Ã—+`)âˆ¾+Â´)sâˆ§q  # Start at sâˆ§q; exclude q, eo, dr
  str â† sg âŠ” xe                     # Strings

  # Numbers and constants
  b â† s âˆ¨ ğ•©âˆŠ@+9â€¿10â€¿13â€¿32            # Whitespace (blank)
  l â† Â¬ b âˆ¨ ğ•©âˆŠ"""{}[],:"            # Word characters
  w â† Â»âŠ¸< l                         # Word starts
  neg â† '-' = ğ•©
  dig â† ('0'â‰¤ğ•©) âˆ§ ğ•©â‰¤'9'
  m â† l âˆ§ (+`w)âŠ0âˆ¾w/digâˆ¨neg         # Numbers
  n â† mâˆ§w â‹„ k â† m<w                 # Number and constant starts
  "Leading zero" ! Â¬âˆ¨Â´(nâ‰ Â»âŠ¸âˆ¨nâˆ§neg)âˆ§('0'=ğ•©)âˆ§Â«dig
  "Digits required on both sides of decimal" ! âˆ§Â´(mâˆ§'.'=ğ•©)â‰¤(Â»âˆ§Â«)dig
  cns â† Consts (1-Ëœ(m<l)Ã—+`k)âŠ”ğ•©     # Constants
  num â† â€¢ParseFloatÂ¨ (1-ËœmÃ—+`n)âŠ”ğ•©   # Numbers

  # Tokenize
  f â† Â¬bâˆ¨w<l                        # First characters of tokens
  tok â† '0'Â¨âŒ¾((f/n)âŠ¸/) 'a'Â¨âŒ¾((f/k)âŠ¸/) f/ğ•©
  âŸ¨tok, cns, num, strâŸ©
}

Parse â† {
  "Empty input" ! 0<â‰ ğ•©
  tâ€¿cnsâ€¿numâ€¿strk â† Tokenize ğ•©

  # Validate (incomplete)
  q â† '"'=t
  c â† ':'=t
  "Object keys must be strings" ! âˆ§Â´(Â»q)â‰¥c
  g â† â‹+`(coâ†tâˆŠ"[{")-ccâ†tâˆŠ"]}"      # Bracket depth ordering indices
  u â† gâŠt
  r â† +` s â† uâˆŠ"[{"
  o â† s/'{'=u                       # Container is object
  "Improper , or : usage" ! (1â‰ `Â¬Â»âŠ¸âˆ§s) â‰¡ sâˆ¨uâˆŠ",:"
  RunLen â† (1+â†•âˆ˜â‰ )(âŠ£-âŒˆ`âˆ˜Ã—)Â¬
  p â† 4 | RunLen r âŠ 0âˆ¾o            # Position within object
  "Improper : usage" ! (u=':') â‰¡ 3=p
  "Object ends cefore key-value pair completed" ! Â¬âˆ¨Â´sâˆ§Â»0â‰ p

  # Keys
  l â† (â‹g) âŠ r                      # Container index
  j â† +`âŠ¸Ã— o                        # Object index (start at 1; 0 if list)
  keys â† ((q/(Â«c)Ã—lâŠ0âˆ¾j)âˆ¾1+Â´o) âŠ” strk
  str â† âŠ‘keys

  # Build collections
  nv â† â‰  vals â† âˆ¾cnsâ€¿numâ€¿str        # Initial set of values
  f â† Â¬(Â«âŠ¸âˆ¨c)âˆ¨coâˆ¨','=t              # Filter for just values a0"]}
  viâ† â‹â‹(f/'0'=t)+(2Ã—f/q)+3Ã—f/cc    # Value indices
  i â† vi âŠ (â†•nv) âˆ¾ nv+â‰ âŠ¸-cc/Â»l      # Adjust for collection ordering
  j {valsâˆ¾â†©<ğ•¨âŠ‘âŸœkeysâŠ¸â‰âŸ(0<âŠ£)ğ•©âŠvalsâ‹„@}Â¨â—‹âŒ½ ((â‰ j)âˆ¾Ëœ1-Ëœf/l)âŠ”i
  Â¯1âŠ‘vals
}
