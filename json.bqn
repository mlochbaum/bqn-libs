# JSON: JavaScript Object Notation
âŸ¨
  Parse  # JSON string to BQN
âŸ©â‡

âŸ¨ConstsâŸ© â† {
  val â† <Â¨ name â† "true"â€¿"false"â€¿"null"
  Consts â‡ {
    i â† name âŠ ğ•©
    "Unknown constant" ! âˆ§Â´ i<â‰ name
    i âŠ val
  }
}
âŸ¨UnEscapeâŸ© â† {
  in â† """\/bfrnt"
  out â† (3â†‘in)âˆ¾@+8â€¿12â€¿13â€¿10â€¿9
  diff â† (out-in) âˆ¾ 0
  Basic â† {
    i â† in âŠ ğ•©
    "Unknown escape" ! âˆ§Â´ğ•¨â‰¤i<â‰ in
    ğ•© + ğ•¨ Ã— i âŠ diff
  }

  hc â† "0Aa"
  hb â† â¥Šhc+0â‰Ë˜10â€¿6â€¿6   # Hex boundaries, start and after-end
  ho â† 2/hc-0â€¿10â€¿10    # Corresponding offsets
  Hex â† { u ğ•Š ğ•©:
    d â† ğ•© /Ëœ m â† â‰ ` (4â¥Š0)âŠ¸Â»âŠ¸â‰  Â»u
    t â† hb â‹ d
    "String \u must be followed by 4 hex characters" ! âˆ§Â´1=2|t
    # Now m can't run past the end or self-intersect,
    # or it would have hit a closing quote or backslash
    v â† 16âŠ¸Ã—âŠ¸+ËœËâŒ½ â‰âˆ˜â€¿4â¥Š d-tâŠho
    âŸ¨(v+@-'u')âŠ¸+âŒ¾(uâŠ¸/)ğ•©, mâŸ©
  }

  UnEscape â‡ { e ğ•Š ğ•©:
    u â† e âˆ§ ğ•©='u'
    (u<e)âŠ¸BasicâŒ¾âŠ‘ u HexâŸœâŠ‘âŸ(âˆ¨Â´u) ğ•©â€¿0
  }
}
wsâ†@+9â€¿10â€¿13â€¿32 # whitespace

# JSON to âŸ¨tokens, constants, numbers, stringsâŸ©
# Tokens are characters {}[],: and a constant, 0 number, " string
# Values correspond to a, 0, and " in order
Tokenizeâ†{
  # Strings
  e â† Â»eo â† <`'\'=ğ•©
  s â† â‰ `q â† e<'"'=ğ•©
  "Unclosed quote" ! Â¬Â¯1âŠ‘s
  "Backslash outside string" ! âˆ§Â´sâ‰¥e
  xeâ€¿dr â† e UnEscape ğ•©              # Escaped ğ•©; characters to drop
  sg â† ((1-Ëœ(s>qâˆ¨eoâˆ¨dr)Ã—+`)âˆ¾+Â´)sâˆ§q  # Start at sâˆ§q; exclude q, eo, dr
  str â† sg âŠ” xe                     # Strings

  # Numbers and constants
  wâ†Â»âŠ¸<lâ†Â¬sâˆ¨ğ•©âˆŠ"""{}[],:"âˆ¾ws         # Word chars l, start w
  nâ†lâˆ§(+`w)âŠ0âˆ¾('-'âˆ¾'0'+â†•10)âˆŠËœw/ğ•©    # Number starts
  kâ†n<w                             # Constant starts
  cns â† Consts (1-Ëœ(n<l)Ã—+`k)âŠ”ğ•©     # Constants
  num â† â€¢ParseFloatÂ¨ (1-ËœnÃ—+`nâˆ§w)âŠ”ğ•© # Numbers

  # Tokenize
  f â† Â¬(ğ•©âˆŠws)âˆ¨(w<l)âˆ¨s               # First characters of tokens
  tok â† '0'Â¨âŒ¾((f/n)âŠ¸/) 'a'Â¨âŒ¾((f/k)âŠ¸/) f/ğ•©
  âŸ¨tok, cns, num, strâŸ©
}

Parse â† {
  "Empty input" ! 0<â‰ ğ•©
  tâ€¿cnsâ€¿numâ€¿strk â† Tokenize ğ•©

  # Validate (incomplete)
  q â† '"'=t
  c â† ':'=t
  "Object keys must be strings" ! âˆ§Â´(Â»q)â‰¥c
  g â† â‹+`(coâ†tâˆŠ"[{")-ccâ†tâˆŠ"]}"      # Bracket depth ordering indices
  u â† gâŠt
  r â† +` s â† uâˆŠ"[{"
  o â† s/'{'=u                       # Container is object
  "Improper , or : usage" ! (1â‰ `Â¬Â»âŠ¸âˆ§s) â‰¡ sâˆ¨uâˆŠ",:"
  RunLen â† (1+â†•âˆ˜â‰ )(âŠ£-âŒˆ`âˆ˜Ã—)Â¬
  p â† 4 | RunLen r âŠ 0âˆ¾o            # Position within object
  "Improper : usage" ! (u=':') â‰¡ 3=p
  "Object ends cefore key-value pair completed" ! Â¬âˆ¨Â´sâˆ§Â»0â‰ p

  # Keys
  l â† (â‹g) âŠ r                      # Container index
  j â† +`âŠ¸Ã— o                        # Object index (start at 1; 0 if list)
  keys â† ((q/(Â«c)Ã—lâŠ0âˆ¾j)âˆ¾1+Â´o) âŠ” strk
  str â† âŠ‘keys

  # Build collections
  nv â† â‰  vals â† âˆ¾cnsâ€¿numâ€¿str        # Initial set of values
  f â† Â¬(Â«âŠ¸âˆ¨c)âˆ¨coâˆ¨','=t              # Filter for just values a0"]}
  viâ† â‹â‹(f/'0'=t)+(2Ã—f/q)+3Ã—f/cc    # Value indices
  i â† vi âŠ (â†•nv) âˆ¾ nv+â‰ âŠ¸-cc/Â»l      # Adjust for collection ordering
  j {valsâˆ¾â†©<ğ•¨âŠ‘âŸœkeysâŠ¸â‰âŸ(0<âŠ£)ğ•©âŠvalsâ‹„@}Â¨â—‹âŒ½ ((â‰ j)âˆ¾Ëœ1-Ëœf/l)âŠ”i
  Â¯1âŠ‘vals
}
