# JSON: JavaScript Object Notation
âŸ¨
  Parse   # JSON string to BQN
  Export  # BQN value to JSON (also Parseâ¼)
âŸ©â‡

# JSON numbers, strings, and lists correspond directly to BQN
# Objects are represented as keysâ‰values
# true, false, null are represented as <"true", <"false", <"null"

# An empty list exports as "" if its fill is a space and [] otherwise

âŸ¨Consts, ExportConstâŸ© â† {
  val â† <Â¨ name â† "true"â€¿"false"â€¿"null"
  Consts â‡ {
    i â† name âŠ ğ•©
    "Unknown constant" ğ• i = â‰ name  # ğ• formats errors
    i âŠ val
  }
  cm â† "Enclosed value must be JSON constant"âˆ¾âˆ¾' 'âŠ¸âˆ¾Â¨"or "âŠ¸âˆ¾âŒ¾(Â¯1âŠ¸âŠ‘)name
  ExportConst â‡ {
    i â† valâŠ¸âŠâŒ¾< ğ•©
    cm ! i<â‰ val
    i âŠ‘ name
  }
}
âŸ¨UnEscape, EscapeâŸ© â† {
  in â† """\/bfrnt"
  out â† (3â†‘in)âˆ¾@+8â€¿12â€¿13â€¿10â€¿9
  diff â† (out-in) âˆ¾ 0
  Basic â† {
    i â† in âŠ ğ•©
    "Unknown escape" ! âˆ§Â´ğ•¨â‰¤i<â‰ in
    ğ•© + ğ•¨ Ã— i âŠ diff
  }

  hc â† "0Aa"
  hb â† â¥Šhc+0â‰Ë˜10â€¿6â€¿6   # Hex boundaries, start and after-end
  ho â† 2/hc-0â€¿10â€¿10    # Corresponding offsets
  Hex â† { u ğ•Š ğ•©:
    d â† ğ•© /Ëœ m â† â‰ ` (4â¥Š0)âŠ¸Â»âŠ¸â‰  Â»u
    t â† hb â‹ d
    "String \u must be followed by 4 hex characters" ! âˆ§Â´1=2|t
    # Now m can't run past the end or self-intersect,
    # or it would have hit a closing quote or backslash
    v â† 16âŠ¸Ã—âŠ¸+ËœËâŒ½ â‰âˆ˜â€¿4â¥Š d-tâŠho
    wâ€¿e â† Surrogate v
    âŸ¨(w+@-'u')âŠ¸+âŒ¾(uâŠ¸/)ğ•©, eâŒ¾(uâŠ¸/)mâŸ©
  }
  sr â† 2â‹†10            # Surrogate base/radix
  sb â† srÃ—52+2+â†•3      # Surrogate character boundaries
  Surrogate â† {
    c â† (â‰ sb)|sbâ‹ğ•©     # 0 for non-surrogate, 1 then 2 for surrogate
    h â† 1=c            # First half
    "Unmatched surrogate pair" ! (0âˆ¾h) â‰¡ (2=c)âˆ¾0
    r â† ğ•© - câŠ0âˆ¾sb     # Numeric value of surrogates
    v â† r + Â»hÃ—srÃ—(2â‹†6)+r
    âŸ¨v, hâŸ©
  }

  UnEscape â‡ { e ğ•Š ğ•©:
    u â† e âˆ§ ğ•©='u'
    (u<e)âŠ¸BasicâŒ¾âŠ‘ u HexâŸœâŠ‘âŸ(âˆ¨Â´u) ğ•©â€¿0
  }

  Hex32 â† {                # Convert ğ•©<32 to two hex digits
    uâ€¿l â† 16(âŒŠâˆ˜Ã·Ëœâ‹ˆ|)ğ•©      # Upper and lower digits; âˆ§Â´u<2
    '0'+uâ‰Ë˜l-(10+-Â´"0A")Ã—10â‰¤l
  }
  Escape â‡ {
    e â† (ğ•©âˆŠ2â†‘in) âˆ¨ ğ•©<@+32  # Quote, backslash, and control characters
    j â† /e â‹„ k â† Â¬e        # Their indices; characters to keep
    c â† j âŠ ğ•©              # Characters to be escaped
    m â† c - (outâŠc)âŠdiff   # Escape the basic ones
    g â† 2 âˆ¾Ëœ m<@+32        # Group ğ•¨ to separate...
    nâ€¿u â† g âŠ” m            # Characters requiring basic, hex escapes
    i â† âˆ¾âŸ¨/kâŸ©âˆ¾2â€¿6/Â¨gâŠ”j     # Target indices
    i â‹âŠ¸âŠ âˆ¾âŸ¨               # Use them to reorder:
      k/ğ•©                  # Kept characters
      â¥Š'\'â‰Ë˜n              # Basic escapes
      â¥Š"\u00"âŠ¸âˆ¾Ë˜ Hex32 u-@ # Hex escapes
    âŸ©
  }
}

# Format error with message ğ•¨ at locations ğ•© in ğ•—
_fmtErr â† { msg src _ğ•£ pos:
  lf â† @+10
  s â† 0âˆ¾1+ bâ†/src=lf                # Line start and break positions
  l â† (1â†“s) â‹ pos                   # Error line numbers
  c â† pos - lâŠs                     # Error column numbers
  d â† âŠ‘l                            # First line only
  1â†“âˆ¾lfâŠ¸âˆ¾Â¨ âŸ¨
    msg
    (dâŠ‘s)â†“(dâŠ‘bâˆ¾â‰ src)â†‘src            # Display first line
    " ^" âŠËœ /â¼ (d=l)/c              # And carets under errors
  âŸ©âˆ¾{
    n â† â‰  a â† dâŠ¸â‰ âŠ¸/l                # 1-indexed numbers of other lines
    0<n ? â‹ˆ((-1=n)â†“"Also lines")âˆ¾1â†“âˆ¾â¥Š(<", ")â‰Ë˜â€¢ReprÂ¨1+a
    ; âŸ¨âŸ©
  }
}

# JSON to âŸ¨tokens, constants, numbers, stringsâŸ©
# Tokens are characters {}[],: and a constant, 0 number, " string
# Values correspond to a, 0, and " in order
Tokenize â† {
  FE â† ğ•©_fmtErr â‹„ _err â† {(! ğ•— FE /)âŸ(âˆ¨Â´)}
  # Strings
  e â† Â»eo â† <`'\'=ğ•©
  s â† â‰ `q â† e<'"'=ğ•©
  "Unclosed quote" ! Â¬Â¯1âŠ‘s
  "Backslash outside string"_err s<eo
  "Un-escaped control character"_err s>ğ•©â‰¥@+32
  xeâ€¿dr â† e UnEscape ğ•©              # Escaped ğ•©; characters to drop
  sg â† ((1-Ëœ(s>qâˆ¨eoâˆ¨dr)Ã—+`)âˆ¾+Â´)sâˆ§q  # Start at sâˆ§q; exclude q, eo, dr
  str â† sg âŠ” xe                     # Strings

  # Numbers and constants
  b â† s âˆ¨ ğ•©âˆŠ@+9â€¿10â€¿13â€¿32            # Whitespace (blank)
  l â† Â¬ b âˆ¨ ğ•©âˆŠ"""{}[],:"            # Word characters
  w â† Â»âŠ¸< l                         # Word starts
  neg â† '-' = ğ•©
  dig â† ('0'â‰¤ğ•©) âˆ§ ğ•©â‰¤'9'
  m â† l âˆ§ (+`w)âŠ0âˆ¾w/digâˆ¨neg         # Numbers
  n â† mâˆ§w â‹„ k â† m<w                 # Number and constant starts
  "Leading zero"_err (nâ‰ Â»âŠ¸âˆ¨nâˆ§neg)âˆ§('0'=ğ•©)âˆ§Â«dig
  "Digits required on both sides of decimal"_err (mâˆ§'.'=ğ•©)>(Â»âˆ§Â«)dig
  CE â† {(! ğ•¨ FE /âŸœ(/k))âŸ(âˆ¨Â´) ğ•©}
  cns â† ce Consts (1-Ëœ(m<l)Ã—+`k)âŠ”ğ•©  # Constants
  num â† â€¢ParseFloatÂ¨ (1-ËœmÃ—+`n)âŠ”ğ•©   # Numbers

  # Tokenize
  f â† Â¬bâˆ¨w<l                        # First characters of tokens
  tok â† '0'Â¨âŒ¾((f/n)âŠ¸/) 'a'Â¨âŒ¾((f/k)âŠ¸/) f/ğ•©
  âŸ¨tok, f, cns, num, strâŸ©
}

Parse â† {
  ğ•Šâ¼ğ•©: Export ğ•© ;
  "Empty input" ! 0<â‰ ğ•©
  tâ€¿tfâ€¿cnsâ€¿numâ€¿strk â† Tokenize ğ•©
  "Empty input" ! 0<â‰ t

  # Validate
  # _tr records persistent transformations
  # Temporary transformations are passed to _err_ as ğ”½
  trs â† âŸ¨tf,/âŸ© â‹„ _tr â† {trsâˆ¾â†©âŸ¨ğ•¨âŠ¸ğ”½âŸ©â‹„ğ•¨ğ”½ğ•©}
  FE â† ğ•©_fmtErr â‹„ _err_ â† {ğ•—{! ğ•— FE ğ•©/ğ”¾{ğ•ğ•©}Â´âŒ½trs}ğ”¾âŸ(âˆ¨Â´)}
  q â† '"'=t
  c â† ':'=t
  "Object keys must be strings"_err_âŠ¢ (Â»q)<c
  g â† â‹+`(coâ†tâˆŠ"[{")-ccâ†tâˆŠ"]}"      # Bracket depth ordering indices
  u â† g âŠ_tr t
  r â† +` s â† uâˆŠ"[{"
  o â† s/'{'=u                       # Container is object
  "Mismatched brackets"_err_{s/ğ•©} o â‰  (uâˆŠ"]}")/'}'=u
  v â† (Â«âŠ¸âˆ¨Â¬s) /_tr u                # Remove empty lists/objects
  vsâ† v âˆŠ "[{,:"                    # Must alternate 0101...10
  "Improper , or : usage"_err_âŠ¢ 1(âˆ¾=âˆ¾Ëœ) vs
  v /_trËœâ†© vs
  # v should be composed of lists [,,, and objects {:,:,:
  # Convert {: to { and ,: to : to get [,,, and {::
  v /_trËœâ†© Â¬((Â»v='{')âŠ¸âˆ§ âˆ¨ (v=',')âˆ§Â«)v=':'
  # Or, every , follows list-like [, and every : follows object-like {:
  d â† vâˆŠ",:"
  "Top-level , or :"_err_{1â†‘ğ•©} 1â†‘d
  "Bad object structure"_err_âŠ¢ d > Â»âŠ¸=vâˆŠ"{:"

  # Keys
  l â† (â‹g) âŠ r                      # Container index
  j â† +`âŠ¸Ã— o                        # Object index (start at 1; 0 if list)
  keys â† ((q/(Â«c)Ã—lâŠ0âˆ¾j)âˆ¾1+Â´o) âŠ” strk
  str â† âŠ‘keys

  # Purely numeric lists
  l âŠâ†© â‹â‹nmâ†0âŒ¾âŠ‘1(âˆ¾/âˆ¾Ëœ)s(âˆ¨/âŠ£)uâˆŠ"]}""a"
  nn â† +Â´Â¬nm
  nl â† numâŠ”Ëœ(1+Â´nm)âˆ¾Ëœ0âŠ¸<âŠ¸Ã—(1-nn)+(t='0')/l
  jjâ€¿jn â† 2â†‘(1â†“nm)âŠ”j
  Ob â† âŠ‘âŸœkeysâŠ¸â‰âŸ(0<âŠ£)
  n â† jn ObÂ¨ 1â†“nl

  # Build collections
  nvâ† n -Ëœâ—‹â‰  valsâ†âˆ¾âŸ¨cns,âŠ‘nl,str,âŒ½nâŸ© # Initial set of values
  f â† (l<nn)âˆ§Â¬(Â«âŠ¸âˆ¨c)âˆ¨coâˆ¨','=t       # Filter for just values a0"]}
  viâ† â‹â‹(f/'0'=t)+(2Ã—f/q)+3Ã—f/cc    # Value indices
  i â† vi âŠ (â†•nv) âˆ¾ nv+â‰ âŠ¸-cc/Â»l      # Adjust for collection ordering
  jj {valsâˆ¾â†©âŸ¨ğ•¨ Ob ğ•©âŠvalsâŸ©â‹„@}Â¨â—‹âŒ½ ((â‰ jj)âˆ¾Ëœ1-Ëœf/l)âŠ”i
  Â¯1âŠ‘vals
}

ExportNumber â† {
  "NaN can't be represented in JSON" ! =Ëœğ•©
  "Infinities can't be represented in JSON" ! âˆâ‰ |ğ•©
  r â† â€¢Repr ğ•©
  r + (-Â´"-Â¯")Ã—r='Â¯'
}
IsString â† {âˆ§Â´2=â€¢TypeÂ¨ 1âŠ¸â†‘âŸ(0=â‰ ) ğ•©}
ExportList â† {
  IsString ğ•© ? ExportString ğ•© ;
  âˆ¾ âŸ¨"["âŸ©âˆ¾âŸ¨"]"âŸ©âˆ¾Ëœ 1â†“â¥Š(<",")â‰Ë˜ExportÂ¨ ğ•©
}
ExportString â† '"' (âˆ¾âˆ¾âŠ£) Escape
ExportObject â† {
  "Object must consist of keysâ‰values" ! 2=â‰ ğ•©
  [k,v] â† ğ•©
  "Object keys must be strings" ! âˆ§Â´ IsStringÂ¨ k
  kv â† â¥Š (ExportStringÂ¨ k) â‰Ë˜ ExportÂ¨ v
  âˆ¾ âŸ¨"{"âŸ©âˆ¾âŸ¨"}"âŸ©âˆ¾Ëœ Â¯1â†“â¥Š kv â‰Ë˜ (â‰ kv) â¥Š âŸ¨":",","âŸ©
}
Export â† (2âŒŠâ€¢Type)â—¶âŸ¨ # Check type
  (3âŒŠ=)â—¶âŸ¨            # Type 0, array: Check rank
    ExportConst      #   0 constant (enclosed string)
    ExportList       #   1 List or string
    ExportObject     #   2 Object
    !âˆ˜"Rank >2 cannot be exported to JSON"
  âŸ©
  ExportNumber       # Type 1: number
  !âˆ˜"Only numbers and arrays can be exported to JSON"
âŸ©
