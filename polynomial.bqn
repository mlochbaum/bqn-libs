âŸ¨
  Trim, Add, Sub, Mul
  Derivative, Integral
  Eval, _fn
  LaguerreRoots, AberthRoots, WeierstrassRoots
âŸ©â‡

# Arithmetic for real polynomials
Trim â† (âˆ¨`âŒ¾âŒ½0âŠ¸â‰ )âŠ¸/
Add â† +Â´ ((âŒˆÂ´â‰ Â¨)â†‘Â¨âŠ¢)âŠ˜(âŒˆâ—‹â‰ â†‘Â¨â‹ˆ)  # Like +Â´âŠ˜+
Sub â† -Â´ âŒˆâ—‹â‰  â†‘Â¨ â‹ˆ
Mul â† +Â´Â¨ +âŒœâ—‹(â†•â‰ ) âŠ” Ã—âŒœ

Derivative â† 1 â†“ â†•âˆ˜â‰ âŠ¸Ã—
Integral   â† {ğ•Š:(<ğ•¨âŠ£0)âˆ¾ğ•©Ã·1+â†•â‰ ğ•©; ğ•Šâ¼:Derivativeğ•©}

_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}

complex â† {
  M â‡ -Â´âˆ˜Ã—â‹ˆ+Â´âˆ˜Ã—âŸœâŒ½
  D â‡ (-âŒ¾(1âŠ¸âŠ‘) Ã· +Ëâˆ˜(Ã—Ëœ)){ğ”½âŠ˜(MâŸœğ”½)}
  A2â‡ +Â´âˆ˜Ã—Ëœ
  A â‡ âˆšA2
  Sqrt â‡ { 0<mâ†Ağ•© ? sâ€¿tâ†0>aâ€¿bâ†ğ•© â‹„ -âŸtâˆ˜âŒ½âŸs (Ã·âŸœ2â‹ˆbâŠ¸Ã·) âˆš2Ã—m+|a ; 0â€¿0 }
  _poly â‡ {+âŸœ(ğ•©âŠ¸M)Â´ğ•—}
  _polyd_ â‡ {(ğ•˜â€¿2â¥Š0) (Â»+ğ•©âŠ¸MË˜âˆ˜âŠ¢)Â´ ğ•—}
  _polyd_ek_ â‡ {
    ekâ†0 â‹„ axâ†Ağ•©
    v â† (ğ•˜â€¿2â¥Š0) {ekâ†©(AâŠğ•©)+axÃ—ekâ‹„ğ•©}âˆ˜(Â»+ğ•©âŠ¸MË˜âˆ˜âŠ¢)Â´ ğ•—
    vâ€¿ek
  }
}
CPoly â† â‹ˆâŸœ0âŸ(0==)Â¨

# Evaluate polynomial
_fn â† {(CPolyğ•—)complex._poly}
Eval â† {ğ•¨_fn ğ•©}

# Analytical solutions to low-order polynomials
exact â† {
  Mâ€¿Dâ€¿Sqrt â† complex
  Low â† !âˆ˜"Input must have degree at least 1"
  Lin â† -âˆ˜DÂ´âŠ¢
  Quad â† { ğ•¨ ğ•Š câ€¿bâ€¿a:
    b Ã·â†© Â¯2
    0â€¿0âŠ¸â‰¢â—¶âŸ¨â‹ˆËœ,câŠ¸Dâ‹ˆDâŸœaâŸ© b(0â‰¤+Â´âˆ˜Ã—)â—¶âŸ¨+,-âŸ© Sqrt (MËœb) - a M c
  }
  _with â‡ {(4âŒŠâ‰ âˆ˜âŠ¢)â—¶Lowâ€¿Lowâ€¿Linâ€¿Quadâ€¿ğ”½}
}

# Return all complex roots of little-endian polynomial ğ•©, using
# simultaneous root-finding methods
# ğ•¨ gives the number of iterations
# Result is a list of realâ€¿imag pairs
_allRoots_ â† { GetStep _ğ•£_ deriv:
  Mâ€¿Dâ€¿A2â€¿_polyd_ek_ â† complex
  max_iter â† 100
  {
    eps  â† ğ•¨âŠ£1eÂ¯16
    step â† GetStep n â† 1-Ëœâ‰ ğ•©
    Poly â† (MÂ¨âŸœ(DÂ¨Â¯1âŠ¸âŠ)ğ•©) _polyd_ek_ deriv
    r    â† <Ë˜â‰> 1â€¿0 MâŸ(â†•n)Ëœ 4â€¿9Ã·10  # Initial roots: 0.4i0.9â‹†â†•n
    i â† 0
    âŠ¢_while_ {ğ•¤
      pâ€¿ek â† Poly r
      âˆ¨Â´ (eps Ã— Ã—Ëœek) â‰¤ A2 âŠp ?
      r StepËœâ†© p
      "Failed to converge" ! max_iter > i+â†©1
      1;0
    }@
    <Ë˜â‰> r
  }exact._with {ğ•¨ğ”½CPolyğ•©}
}
âŸ¨WeierstrassRootsâ‡WR, AberthRootsâ‡ARâŸ© â† {
  Mâ€¿D â† complex
  WR â‡ { âŠ¢ - âŠ âŠ¸  D       âŸœ(MËÂ·â‰(1â€¿0Ã—âŒœ=âŸœ<â†•ğ•©)+Â·><âŠ¸-Â¨)  } _allRoots_ 1
  AR â‡ { âŠ¢ - DËâŠ¸(âŠ£D 1â€¿0+M)âŸœ(Â¯1â€¿0+ËÂ¨(â‹ˆâŸœ0=âŒœËœâ†•ğ•©)Dâˆ˜+-âŒœËœÂ¨) } _allRoots_ 2
}

# Find a root of the given polynomial with Laguerre's method
_laguerre_ â† {poly _ğ•£_ eps root:
  Mâ€¿Dâ€¿Aâ€¿A2â€¿Sqrtâ€¿_polyd_ek_ â† complex
  Jump â† (â€¢MakeRand 1).Rangeâˆ˜0 â‹„ jump_i â† 10

  nk2 â† 2 Ã· nrn â† Â¬ rn â† Ã· 1-Ëœâ‰ poly
  F â† (CPoly poly) _polyd_ek_ 3
  max_iter â† 200
  i â† 0
  âŠ¢_while_ {ğ•¤
    i < max_iter ?
    âŸ¨pâ€¿dpâ€¿d2p_h, ekâŸ© â† <Ë˜âŒ¾âŠ‘ F root
    0 < a2p â† A2 p ?
    crit â† eps Ã— Ã—Ëœek  # Square of stopping criterion
    stop â† { a2p â‰¥      crit ? 0   # keep going
           ; a2p â‰¥ 0.01Ã—crit ? 1   # finish this iteration, then stop
           ;                   2 } # return immediately
    2 > stop ?
    dx â† {
      # Division by zero: jump in random direction
      0â€¿0 â‰¡ dp ? (1 + A root) Ã— (â€¢math.Sinâ‹ˆâ€¢math.Cos) (2Ã—Ï€) Ã— Jump i ;
      # Otherwise, Laguerre step
      fac â† pâ€¿d2p_h MÂ¨ <D dp
      (âŠ‘fac) D rnâ€¿0 + nrn Ã— -âŸ(0>âŠ‘) Sqrt 1â€¿0 - nk2 Ã— MÂ´ fac
    }
    (root -â†© dx) â‰¢ root ?
    Â¬stop ?
    i+â†©1
    # Randomly reduce length every few steps
    { 0=jump_i|i ? root +â†© dx Ã— Jump iÃ·jump_i ;@}
    1;0
  }@
  root
}

# Find all roots, with linear/quadratic formulas and Laguerre
_laguerreRootsPolish â† {
  eps â† ğ•¨âŠ£1eÂ¯16
  âŸ¨MâŸ© â† complex
  Solve â† {
    root â† ğ•© _laguerre_ eps 0â€¿0
    root <âŠ¸âˆ¾ Solve MâŸœrootâŠ¸+`âŒ¾âŒ½ 1â†“ğ•©
  } exact._with
  {ğ•¨ _laguerre_ epsÂ¨âŒ¾(1âŠ¸â†“) ğ•©}âŸğ•—âŸœSolve exact._with CPoly ğ•©
}
LaguerreRoots â† 1 _laguerreRootsPolish
