âŸ¨
  _join
  Split, Locate
  ReplaceAll
  _template
  tab,lf,cr,crlf, JoinLines
  Trim
  ToBytes, FromBytes
  ToNats, ToNums
âŸ©â‡

# Whitespace characters: tab, linefeed, carriage return
tabâ€¿lfâ€¿cr â† @+9â€¿10â€¿13
crlf â† crâ€¿lf  # Windows-style line separator

# Convert lines to lf-separated string, including trailing lf
JoinLines â† âˆ¾ âˆ¾âŸœlfÂ¨

# "sep"_join is like âˆ¾ but inserts "sep" between any joined strings
_join â† {âˆ¾1â†“â¥Š(<ğ•—)â‰Ë˜ğ•© ; âˆ¾ğ•¨â€¿ğ•—â€¿ğ•©}

# Remove leading (âˆ§`) and trailing (âˆ§`âŒ¾âŒ½) spaces
Trim â† ((âˆ¨` âˆ§ âˆ¨`âŒ¾âŒ½) ' 'âŠ¸â‰ )âŠ¸/

# Given strings â¥Šğ•¨ and ğ•©, return âŸ¨start_mask, keep_maskâŸ© for split
MarkSplit â† (2âŒŠâ‰ âˆ˜âŠ£)â—¶{ğ•¤
  ! "Split: ğ•¨ can't be empty"
}â€¿{
  â‹ˆâŸœÂ¬ (âŸ¨âŸ©â¥Šğ•¨)=ğ•©
}â€¿{
  c â† (â‰ ğ•¨)-1                  # ğ•¨â·ğ•©      011000010011    (câ†3)
  i â† 0 (-âŸœ1âŒˆcÃ—<)` (â‰ ğ•©)â†‘ğ•¨â·ğ•©   # i        032100032103210
  âŸ¨c=i,1âŠ¸Â»âŠ¸âˆ§0=iâŸ©              # 1âŠ¸Â»âŠ¸âˆ§0=i 100001100000000
}

# Return mask of non-overlapping positions in ğ•© where ğ•¨ is found
# Like ğ•¨â·ğ•© but same length as ğ•© and suppressing overlaps (leftmost wins)
Locate â† âŠ‘ MarkSplit

# Split string ğ•© on occurrences of separator ğ•¨, removing the separators
Split â† (0<â‰ âˆ˜âŠ¢)â—¶âŸ¨
  â‹ˆâŠ¢
  (1+`âŠ¢)âŠ¸((1-ËœÃ—)âˆ¾Â¯1âŠâŠ£)Â´âˆ˜MarkSplitâŸ(0<â‰ âˆ˜âŠ¢) âŠ” âŠ¢
âŸ©

# Replace each instance of a string in old with the corresponding
# string in new.
# Instances are non-overlapping, and earlier ones take precedence.
ReplaceAll â† { âŸ¨old,newâŸ© ğ•Š str:
  ! (â‰ new) â‰¡ l â† â‰ old
  match â† 1-Ëœ (l+1)|âŒŠÂ´ (â†•âŠ¸-l) Ã— old LocateÂ¨ <str
  cont â† (-âŸœ1âŒˆâ‰¤âŸœ1Ã—âŠ¢)` match âŠ (â‰ Â¨old)âˆ¾0
  keep â† â‹ˆâŸœ(âŠâŸœstr) / 0=cont
  insert â† (newâŠËœâŠâŸœmatch)âŠ¸(â‰ Â¨âŠ¸/â‹ˆâˆ¾âˆ˜âŠ£) / (0âŠ¸<âˆ§Â»âŠ¸â‰¤) cont
  â‹âŠ¸âŠÂ´ keep âˆ¾Â¨ insert
}

# Replace instances of ğ•— in ğ•¨ with successive elements of ğ•©
_template â† { âˆ¾ 1 (â†‘âˆ¾Â·â¥Šğ•©â‰Ë˜â†“) ğ•— Split ğ•¨ }

# UTF-8 conversions
ToBytes â† âˆ¾ (2â‹†7)âŠ¸(âŠ£+(2â‹†6){ğ•¨ â‰¤â—¶âŸ¨â¥ŠâŠ¢-2Ã—-âŸœğ•— â‹„ ğ•—(|âˆ¾Ëœ(2Ã·ËœâŒŠâŸœğ•¨)ğ•ŠâŒŠâˆ˜Ã·Ëœ)âŠ¢âŸ© ğ•©}Â¨)âŒ¾(-âŸœ@)
FromBytes â† (+`2â‹†7-â†•5){
  tâ†ğ•—â‹ğ•©
  !((/Â¬âŸ(<âŸœ2)Â¨)â‰¡Â·âŒˆ`1âŠ¸â‰ Ã—â†•âˆ˜â‰ )t
  !(â†•âˆ˜â‰ â‰¡Â·âŠ’âŠ¸+âˆ˜/Â¬âŸ(<âŸœ2)Â¨)t
  râ†(2â‹†6)âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½Â¨(Â¯1+`tâ‰ 1)âŠ”ğ•©-tâŠÂ»ğ•—
  r
}âŒ¾(-âŸœ@)

# Parse numbers from a string, treating non-numeric characters as
# separators
# Natural numbers recognize digits only
NN â† (>âŸœÂ«0âŠ¸â‰¤) / 0(0âŠ¸â‰¤Ã—Ã—âŸœ10âŠ¸+)`âŠ¢
ToNats â† { NN 10âŠ¸â‰¤âŠ¸(Â¬âŠ¸Ã—-âŠ£) ğ•©-'0' }

# General numbers recognize digits and eE.Â¯-Ï€âˆ (mild extension of BQN)
ToNums â† {
  Tâ†âŒˆ`Ã— â‹„ I1Tâ†(1+â†•âˆ˜â‰ )âŠ¸T
  cdâ†â‰ digâ†('0'+â†•10)âˆ¾"Ï€âˆ" â‹„ valâ†(â†•10)âˆ¾Ï€â€¿1â€¿Â¯1 # âˆ as 1 to avoid âˆÃ—0
  eâ€¿dâ€¿nâ€¿pâ€¿iâ†"e.Â¯Ï€âˆ"=<ğ•© â‹„ eâ€¿nâˆ¨â†©"E-"=<ğ•©
  mâ†dâˆ¨cd>jâ†digâŠğ•©
  sâ†dâˆ¨câ†eâˆ¨zâ†(âˆ§`âŒ¾âŒ½<Â»âŠ¸<)zzâ†Â¬eâˆ¨nâˆ¨m
  "Negative sign in the middle of a number"! âˆ§Â´nâ‰¤1Â»c
  "Portion of a number is empty"! âˆ§Â´Â¬(1Â«s)âˆ§nâˆ¨s
  "Ill-formed decimal or exponent use"! âˆ§Â´(0âŠ¸=âˆ¨Â»âŠ¸<)s/d+2Ã—e
  "Ï€ and âˆ must occur alone"! âˆ§Â´(pâˆ¨i)â‰¤1(Â»âˆ§(pâˆ§Â«e)âˆ¨Â«)zzâˆ¨n>Â»e
  fâ†(17â‰¥Â¬(âŠ¢-T)+`)âŠ¸âˆ§gâ†(Â«â‰¤(d<jâ‰ 0)>â—‹I1TÂ¬)âŠ¸âˆ§m   # No leading 0s; max 17 digits
  vsâ†1â€¿Â¯1âŠËœ(râ†>âŸœÂ»m)/Â»n                      # Negate if Â¯
  vâ†vsÃ—NN valâŠËœ(Â¬d)/(cdÃ—Â¬f)âŒˆj               # Numeric valuesâ€”mantissas and exponents
  vmâ†c/â—‹(1âŒ¾âŠ‘)z                              # Mask of mantissas in v
  dpâ†vm/f(--Â»âŠ¸-(<Ã—âŠ¢)âŠâŸœ(I1TÂ«d)âŠ¸-)â—‹(/>âŸœÂ«)g    # Decimal position
  qâ†10â‹†|eeâ†dp-Ëœvm/Â«vÃ—Â¬vm                    # Power of 10
  qÃ·ËœâŒ¾((0>ee)âŠ¸/)qÃ—âŒ¾((0<ee)âŠ¸/)vm/vÃ—(r/i)âŠ1â€¿âˆ # Correct âˆ then Ã—10â‹†ee
}
