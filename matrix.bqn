âŸ¨
  MP, H
  uTri, qr
  Inverse
  Solve
âŸ©â‡

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ  # matrix product
H  â† +â‰        # conjugate transpose

uTri â† {
  Verify â‡ {
    ! 2==ğ•©
    ! âˆ§Â´â¥Š (ğ•©=0) â‰¥ >âŒœÂ´â†•Â¨â‰¢ğ•©
  }
  Inverse â‡ (1<â‰ )â—¶Ã·â€¿{
    l â† â‰ ğ•©
    m â† âŒˆlÃ·2
    aiâ€¿di â† InverseÂ¨ mâ€¿m(â†‘â‰â—‹<â†“)ğ•©
    b â† âŸ¨m,m-lâŸ©â†‘ğ•©
    x â† - ai MP b MP di
    z â† 0 â¥ŠËœ âŸ¨l-m,mâŸ©
    âˆ¾ aiâ€¿x â‰ zâ€¿di
  }
  Solve â‡ { u ğ•Š b:
    ! u=â—‹â‰ b
    >{
      iâ†1-Ëœâ‰ b
      bpâ€¿biâ†i(â†‘â‰â—‹<âŠ)b
      lpâ€¿liâ†i(â†‘â‰â—‹<âŠ)ğ•©
      bâ†©bp-lpÃ—âŒœnewâ†biÃ·li
      new
    }Â¨âŒ¾âŒ½ <Ë˜â‰u
  }
}

# QR decomposition
qr â† {
  Compose â‡ MPÂ´
  Verify â‡ { ğ•Š qâ€¿r:
    ! âˆ§Â´2==Â¨ğ•©
    ! âˆ§Â´â‰¥â€¿={ğ•Â´â‰¢ğ•©}Â¨ğ•©
    uTri.Verify r
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q
  }
  Inverse â‡ uTri.InverseâŠ¸MPâŸœHËœÂ´
  Solve â‡ { qâ€¿r ğ•Š b: r uTri.Solve (H q) MP b }

  # Recursive Gram-Schmidt
  Decompose â‡ { QR a:
    !2==a â‹„ !â‰¥Â´â‰¢a
    nâ†âŠ¢Â´â‰¢a
    (1<n)â—¶{
      a (Ã·âŸœâŠ‘ â‰â—‹< âŠ¢) âˆš HâŠ¸MP a
    }â€¿{ğ•¤
      m â†âŒˆnÃ·2
      a0â†mâ†‘Ë˜a
      a1â†mâ†“Ë˜a
      q0â€¿r0â†QR a0
      q1â€¿r1â†QR a1 - q0 MP t â† q0 HâŠ¸MP a1
      âŸ¨q0âˆ¾Ë˜q1 , (r0âˆ¾Ë˜t)âˆ¾(-n)â†‘Ë˜r1âŸ©
    }@
  }

  # QR decomposition using Householder reflections.
  DecomposeHH â‡ { ğ•Š a:
    mâ€¿nâ†â‰¢a
    qâ†=âŒœËœâ†•m
    Step â† {ğ•Šk:
      iâ†k+â†•m-k â‹„ _colâ†{âŸ¨i,<ğ•—âŸ©âŠ¸âŠ}
      Normâ†+Ëâˆ˜|âŒ¾(Ã—Ëœ)
      nzâ†Norm zâ†k _col a
      nvâ†Norm vâ†-(nzÃ—Ã—)âŠ¸+âŒ¾âŠz
      vÃ·â†©nv
      HH â† {-âŸœ(v Ã— 2 Ã— (+v) +Â´âˆ˜Ã— âŠ¢)âŒ¾(ğ•¨_col) ğ•©}Â´âŸœâŒ½âŸ(nvâ‰¥2â‹†Â¯52)
      a HHâ†© â†•n
      q HHâ†© â†•m
    }
    StepÂ¨ â†•n
    âŸ¨H q, aÃ—mâ‰¤âŒœâ—‹â†•nâŸ©
  }
}

# Default matrix inverse and solve
Inverse â† qr.Inverse qr.Decompose
Solve â† qr.Decompose âŠ¸ qr.Solve
