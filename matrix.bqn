âŸ¨
  MP, H
  uTri, qr, lup
  Inverse
  Solve
âŸ©â‡

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ  # matrix product
H  â† +â‰        # conjugate transpose

uTri â† {
  Verify â‡ {
    ! 2==ğ•©
    ! âˆ§Â´â¥Š (ğ•©=0) â‰¥ >âŒœÂ´â†•Â¨â‰¢ğ•©
  }
  Inverse â‡ (1<â‰ )â—¶Ã·â€¿{
    l â† â‰ ğ•©
    m â† âŒˆlÃ·2
    aiâ€¿di â† InverseÂ¨ mâ€¿m(â†‘â‰â—‹<â†“)ğ•©
    b â† âŸ¨m,m-lâŸ©â†‘ğ•©
    x â† - ai MP b MP di
    z â† 0 â¥ŠËœ âŸ¨l-m,mâŸ©
    âˆ¾ aiâ€¿x â‰ zâ€¿di
  }
  Solve â‡ { u ğ•Š b:
    ! u=â—‹â‰ b
    >{
      iâ†1-Ëœâ‰ b
      newâ†bÃ·â—‹(iâŠ¸âŠ)ğ•©
      bâ†©b-âŸœ(Ã—âŒœâŸœnew)â—‹(iâŠ¸â†‘)ğ•©
      new
    }Â¨âŒ¾âŒ½ <Ë˜â‰u
  }
}
lTri â† {
  Verify â‡ uTri.Verify â‰
  Inverse â‡ uTri.InverseâŒ¾â‰
}

lup â† {
  Compose â‡ { ğ•Š pâ€¿lâ€¿u: pâŠ¸âŠË˜ l MP u }
  Verify â‡ { ğ•Š pâ€¿lâ€¿u:
    ! â‰¤Â´ mâ€¿n â† â‰¢u
    ! nâ€¿n â‰¡ â‰¢l
    ! (âˆ§p) â‰¡ â†•n
    uTri.Verify u
    lTri.Verify l
    ! âˆ§Â´ 1 = 0â€¿0â‰l
  }
  Inverse â‡ { ğ•Š pâ€¿lâ€¿u: (â‹p) âŠ (uTri.Inverse u) MP lTri.Inverse l }
  Solve â‡ { pâ€¿lâ€¿u ğ•Š ğ•©: (â‹p) âŠ u uTri.Solve l lTri.Solve ğ•© }

  # Recursive method
  Decompose â‡ LU â† (2âŒŠâ‰ )â—¶{
    âŸ¨â†•Â¯1âŠ‘â‰¢ğ•© , 0â€¿0â¥Š0 , ğ•©âŸ©
  }â€¿{
    p â† (+Â´âˆ§`0=v) {âŒ½âŒ¾(0â€¿ğ•¨âŠ¸âŠ)ğ•©}âŸ(0<âŠ£) â†•â‰ vâ†â¥Šğ•©
    âŸ¨p , â‰â‰1 , â‰pâŠvâŸ©
  }â€¿{ ğ•Ša:
    mâ€¿n â† â‰¢a
    m2 â† âŒˆmÃ·2
    a1â€¿a2 â† m2(â†‘â‰â—‹<â†“)a
    p1â€¿l1â€¿u1 â† LU a1
    g1 â† â‹p1
    fe1â† ((m2â†‘g1)âŠ¸âŠË˜ a2) MP uTri.Inverse m2 â†‘Ë˜ u1
    g  â† ((m2â†“g1)âŠ¸âŠË˜ a2) -        fe1 MP m2 â†“Ë˜ u1
    p2â€¿l2â€¿u2 â† LU g
    p3 â† m2(â†•âˆ˜âŠ£âˆ¾+)p2
    h  â† (â‹p3)âŠ¸âŠË˜ u1
    z  â† m2â€¿(m-m2)â¥Š0
    âŸ¨ p1âŠp3 , âˆ¾l1â€¿zâ‰fe1â€¿l2 , hâˆ¾(-n)â†‘Ë˜u2 âŸ©
  }
}

# QR decomposition
qr â† {
  Compose â‡ MPÂ´
  Verify â‡ { ğ•Š qâ€¿r:
    ! âˆ§Â´2==Â¨ğ•©
    ! âˆ§Â´â‰¥â€¿={ğ•Â´â‰¢ğ•©}Â¨ğ•©
    uTri.Verify r
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q
  }
  Inverse â‡ uTri.InverseâŠ¸MPâŸœHËœÂ´
  Solve â‡ { qâ€¿r ğ•Š b: r uTri.Solve (H q) MP b }

  # Recursive Gram-Schmidt
  Decompose â‡ { QR a:
    !2==a â‹„ !â‰¥Â´â‰¢a
    nâ†âŠ¢Â´â‰¢a
    (1<n)â—¶{
      ğ•© (Ã·âŸœâŠ‘ â‰â—‹< âŠ¢) âˆš HâŠ¸MP ğ•©
    }â€¿{ğ•¤
      m â†âŒˆnÃ·2
      a0â†mâ†‘Ë˜ğ•©
      a1â†mâ†“Ë˜ğ•©
      q0â€¿r0â†QR a0
      q1â€¿r1â†QR a1 - q0 MP t â† q0 HâŠ¸MP a1
      âŸ¨q0âˆ¾Ë˜q1 , (r0âˆ¾Ë˜t)âˆ¾(-n)â†‘Ë˜r1âŸ©
    }a
  }

  # Householder reflections: slower; more stable
  DecomposeHH â‡ { ğ•Š a:
    mâ€¿nâ†â‰¢a
    qâ†=âŒœËœâ†•m
    Step â† {ğ•Šk:
      iâ†k+â†•m-k â‹„ niâ†nÃ—i â‹„ _colâ†{(ğ•—+ni)âŠâ¥Š} #{âŸ¨i,<ğ•—âŸ©âŠ¸âŠ}
      Normâ†+Â´âˆ˜|âŒ¾(Ã—Ëœ)
      nzâ†Norm zâ†k _col a
      nvâ†Norm vâ†-(nzÃ—Ã—)âŠ¸+âŒ¾âŠz
      vÃ·â†©nv
      HH â† {-âŸœ(v Ã— 2 Ã— (+v) +Â´âˆ˜Ã— âŠ¢)âŒ¾(ğ•¨_col) ğ•©}Â´âŸœâŒ½âŸ(nvâ‰¥2â‹†Â¯52)
      a HHâ†© â†•n
      q HHâ†© â†•m
    }
    StepÂ¨ â†•n
    âŸ¨H q, aÃ—mâ‰¤âŒœâ—‹â†•nâŸ©
  }
}

# Default matrix inverse and solve
Inverse â† qr.Inverse qr.Decompose
Solve â† qr.Decompose âŠ¸ qr.Solve
