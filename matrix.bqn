âŸ¨
  MP, H, Trace, Determinant
  Inverse, Solve, Eigenvalues, CharPoly
  lTri, uTri, qr, lup, cholesky, symmetric_eigen, svd
âŸ©â‡

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ  # matrix product
H  â† +â‰        # conjugate transpose
Di â† 0â€¿0â‰âŠ¢     # diagonal
_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}

Trace â† +Â´Di

# Lower (lâ†1) or upper (lâ†0) triangular matrix
LUTri â† {ğ•Š l:
  Verify â‡ (lâŠ‘>â€¿<){
    ! 2==ğ•©
    ! âˆ§Â´â¥Š (ğ•©=0) â‰¥ ğ”½âŒœÂ´â†•Â¨â‰¢ğ•©
  }
  Determinant â‡ (âˆ§Â´0âŠ¸â‰ )â—¶âŸ¨0,Ã—Â´âŸ©Di  # Might contain âˆ or NaN
  # Inverse by recursive blocking
  pâ€¿c â† {ğ•Ëœ}Â¨âŸl â‹ˆâ€¿â‰
  Inverse â‡ {
    1â‰¥â‰ ğ•© ? Ã·ğ•© ;
    l â† â‰ ğ•©
    m â† âŒˆlÃ·2
    aiâ€¿di â† InverseÂ¨ mâ€¿m(â†‘Pâ†“)ğ•©
    b â† (m P m-l)â†‘ğ•©
    x â† - ai MP b MP di
    z â† 0 â¥ŠËœ (l-m) P m
    âˆ¾ (ai P x) C (z P di)
  }
  # Forward or backward substitution
  sâ†Â¯1â‹†Â¬l â‹„ jâ†l-1 â‹„ rev â† lâŠ‘{ğ”½âŒ¾âŒ½}â€¿{ğ”½}
  Solve â‡ { t ğ•Š b:
    ! t=â—‹â‰ b
    >{
      newâ†bÃ·â—‹(jâŠ¸âŠ)ğ•©
      bâ†©b-âŸœ(Ã—âŒœâŸœnew)â—‹(sâŠ¸â†“)ğ•©
      new
    }Â¨âˆ˜((sÃ—â†•âˆ˜â‰ )â†“Â¨âŠ¢)_rev <Ë˜â‰t
  }
}
uTriâ€¿lTri â†  LUTriÂ¨ â†•2

# LU decomposition with pivoting
lup â† {
  Compose â‡ { ğ•Š pâ€¿lâ€¿u: pâŠ¸âŠË˜ l MP u }
  Verify â‡ { ğ•Š pâ€¿lâ€¿u:
    ! â‰¤Â´ mâ€¿n â† â‰¢u
    ! mâ€¿m â‰¡ â‰¢l
    ! (âˆ§p) â‰¡ â†•n
    uTri.Verify u
    lTri.Verify l
    ! âˆ§Â´ 1 = Di l
  }
  Inverse â‡ { ğ•Š pâ€¿lâ€¿u: p âŠ u uTri.Solve lTri.Inverse l }
  Solve â‡ { pâ€¿lâ€¿u ğ•Š ğ•©: p âŠ u uTri.Solve l lTri.Solve ğ•© }
  Determinant â‡ { ğ•Š pâ€¿lâ€¿u:
    s â† Â¯1â‹†+Â´âˆ¾(â‰ â†‘â†‘)âŠ¸>p  # Sign of permutation
    s Ã— uTri.Determinant u
  }

  Decompose â‡ {
    1 â‰¥ â‰ ğ•© ? âŸ¨â†•Â¯1âŠ‘â‰¢ğ•©, 1â¥ŠËœâ‹ˆËœâ‰ ğ•©, ğ•©âŸ© ;
    mâ€¿nâ†â‰¢aâ†ğ•©
    [i,lc,d,ur] â† â‰>{ğ•Š:
      i â† âŠ‘âŠâŸœ(âŒˆÂ´)|r0â†âŠa  # Pivot
      d â† âŸ¨i-n-ğ•©,i+1âŸ©    # Drop amounts to cut out i
      a00â€¿a10 â† (âŠ‘â‹ˆ1âŠ¸â†“) iâŠË˜a
      a01 â† âˆ¾â†“âŸœr0Â¨d
      a â†© (âˆ¾Ë˜Â´(1âŠ¸â‹ˆâ†“aË™)Â¨d) - (cnâ†a10Ã·0âŠ¸=âŠ¸+a00)Ã—âŒœa01
      iâ€¿cnâ€¿a00â€¿a01
    }Â¨ â†•m-1
    p â† ((<â†•nÂ¬m)(âŠ£âˆ¾{ğ•©âˆ¾ğ•©âŠ¸â‰¤âŠ¸+ğ•¨}`)âŠ¢)âŒ¾âŒ½ i
    l â† â‰> (-m)â†‘Â¨1âˆ¾Â¨lcâˆ¾<â†•0
    u â†  > (-n)â†‘Â¨(dâˆ¾Â¨(1â†“p)âŠÂ¨ur)âˆ¾<â¥Ša
    âŸ¨â‹âŠ‘p, l, uâŸ©
  }

  # Recursive method, can return NaN for singular matrices
  DecomposeNonSingular â‡ (0<â‰ )â—¶{ âŸ¨â†•Â¯1âŠ‘â‰¢ğ•© , 0â€¿0â¥Š0 , ğ•©âŸ© }â€¿{ LU:
    1<m âŠ£ mâ€¿n â† â‰¢ğ•© ?
    m2 â† âŒˆmÃ·2 â‹„ S â† m2(â†‘â‹ˆâ†“)âŠ¢
    a1â€¿a2 â† Sğ•©
    p1â€¿l1â€¿u1 â† LU a1
    g1â€¿g2 â† Sâ‹p1
    fe1â† (g1âŠ¸âŠË˜ a2) MP uTri.Inverse m2 â†‘Ë˜ u1
    g  â† (g2âŠ¸âŠË˜ a2) -        fe1 MP m2 â†“Ë˜ u1
    p2â€¿l2â€¿u2 â† LU g
    p3 â† m2(â†•âˆ˜âŠ£âˆ¾+)p2
    h  â† (â‹p3)âŠ¸âŠË˜ u1
    z  â† m2â€¿(m-m2)â¥Š0
    âŸ¨ p1âŠp3 , âˆ¾l1â€¿zâ‰fe1â€¿l2 , hâˆ¾(-n)â†‘Ë˜u2 âŸ©
  ;
    p â† ((â‰ v)|+Â´âˆ§`0=v) {âŒ½âŒ¾(0â€¿ğ•¨âŠ¸âŠ)ğ•©}âŸ(0<âŠ£) â†•â‰ vâ†â¥Šğ•©
    âŸ¨p , â‰â‰1 , â‰pâŠvâŸ©
  }
}

# QR decomposition
qr â† {
  Compose â‡ MPÂ´
  Verify â‡ { ğ•Š qâ€¿r:
    ! âˆ§Â´2==Â¨ğ•©
    ! âˆ§Â´â‰¥â€¿={ğ•Â´â‰¢ğ•©}Â¨ğ•©
    uTri.Verify r
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q
  }
  Inverse â‡ uTri.InverseâŠ¸MPâŸœHËœÂ´
  Solve â‡ { qâ€¿r ğ•Š b: r uTri.Solve (H q) MP b }
  AbsDeterminant â‡ { ğ•Š qâ€¿r: | uTri.Determinant r }

  # Recursive Gram-Schmidt
  Decompose â‡ {
    !2==ğ•© â‹„ !â‰¥Â´â‰¢ğ•©
    {QR: 1<nâ†Â¯1âŠ‘â‰¢ğ•© ?
      m â†âŒˆnÃ·2
      a0â†mâ†‘Ë˜ğ•©
      a1â†mâ†“Ë˜ğ•©
      q0â€¿r0â†QR a0
      q1â€¿r1â†QR a1 - q0 MP t â† q0 HâŠ¸MP a1
      âŸ¨q0âˆ¾Ë˜q1 , (r0âˆ¾Ë˜t)âˆ¾(-n)â†‘Ë˜r1âŸ©
    ;
      ğ•© (Ã·âŸœâŠ‘ â‹ˆ âŠ¢) âˆš HâŠ¸MP ğ•©
    }ğ•©
  }

  # Householder reflections: slower; more stable
  DecomposeHH â‡ { ğ•Š a:
    mâ€¿nâ†â‰¢a
    qâ†=âŒœËœâ†•m
    Step â† {ğ•Šk:
      nz â† +Â´âˆ˜|âŒ¾(Ã—Ëœ) z â† âŸ¨k+â†•m-k,<kâŸ©âŠa
      v â† -(nzÃ—Ã—)âŠ¸+âŒ¾âŠz
      v2 â† 2 Ã— (+v) Ã· nvâ†+Â´|Ã—Ëœv
      nvâ‰¥Ã—Ëœ2â‹†Â¯52 ? aâ€¿q -âŸœ((m-âŠ¸â†‘v) Ã—âŒœ v2 +Ëâˆ˜Ã— (-â‰ v)âŠ¸â†‘)Â¨â†© ; @
    }
    StepÂ¨ â†•n
    âŸ¨H q, aÃ—mâ‰¤âŒœâ—‹â†•nâŸ©
  }
}

# Default implementations
Inverse â† qr.Inverse qr.Decompose
Solve â† qr.Decompose âŠ¸ qr.Solve
Determinant â† (âŠ¢Ã—=âˆ§3âŠ¸â‰¥)Â´âˆ˜â‰¢â—¶âŸ¨
  lup.Determinant lup.Decompose
  âŠ‘                     # 1Ã—1
  -Â´Ã—âŸœâŒ½Ë                # 2Ã—2
  +Â´(â†•3)(Ã—ËâŒ½Ë˜){ğ”½--âŠ¸ğ”½}âŠ¢  # 3Ã—3
âŸ©

# Cholesky decomposition
cholesky â† {
  Verify â‡ lTri.Verify
  Compose â‡ MPâŸœH
  Inverse â‡ HâŠ¸MP lTri.Inverse
  Solve â‡ Hâˆ˜âŠ£ uTri.Solve lTri.Solve
  Determinant â‡ Ã—Ëœ lTri.Determinant
  Decompose â‡ { 1<nâ†â‰ ğ•© ?
    m â† âŒˆnÃ·2 â‹„ dâ†m-n
    xâ€¿yâ€¿z â† âŸ¨mâ€¿m,mâ€¿d,dâ€¿dâŸ© â†‘Â¨ <ğ•©
    l0 â† ğ•Š x
    l1 â† ğ•Š z - (tâ†H ly) MP ly â† l0 lTri.Solve y
    âˆ¾ âŸ¨l0,âŸ¨m,-dâŸ©â¥Š0âŸ©â‰âŸ¨t,l1âŸ©
  ;
    ! 0<âŠ‘ğ•©
    âˆšğ•©
  }
}

# Faddeev-LeVerrier algorithm
CharPoly â† {
  !2==ğ•© â‹„ !=Â´â‰¢ğ•©
  idâ†=âŒœËœâ†•nâ†â‰ ğ•©
  câ†-Trace mâ†m0â†ğ•©
  1â€¿c âˆ¾ c { Trace m â†© m0 MP m+ğ•©Ã—id }âŠ¸Ã·` -2+â†•n-1
}

# Shared code for one-sided or two-sided parallel Jacobi method
_JacobiSweep â† { nâ€¿GetSubmatsâ€¿_applyRot _ğ•£:
  # Diagonalize each pair j, jâŠ‘i with a rotation
  # Duplicates the arithmetic for sin and cos but it vectorizes well
  Layer â† { ğ•Š i:
    offâ€¿diag â† GetSubmats i  # âŸ¨ğ•©âŠË˜m, Di mâŸ© to diagonalize symmetric m
    # Required rotation is determined by the ratio uÃ·p
    d â† Ã—i-â†•n
    p â† (2 Ã— dâ‰ 0) Ã— off         # Force to 0 for non-pairs d=0
    u â† (d Ã— iâŠ¸âŠâŠ¸- diag) â‹† pâ‰ 0  # Must be nonzero if p=0
    t â† 2 Ã— v â† p +âŒ¾(Ã—Ëœ) u
    cos â† âˆš(v+|u)Ã·t
    sin â† (dÃ—Â¯1â‹†u<0) Ã— pÃ·tÃ—cos
    (cosâŠ¸Ã— - sinÃ—iâŠ¸âŠ)_applyRot
    @
  }
  # A sweep hits each (unordered) pair of distinct indices once
  r â† âŒ½â†•p â† n-Â¬2|n
  {ğ•Š:
    2|n? (LayerâŒ½âŸœr)Â¨ r;
    (p|(nÃ·2)Ã—â†•p) {Layer ğ•¨âˆ¾ËœpâŒ¾(ğ•¨âŠ¸âŠ‘) ğ•©âŒ½r}Â¨ r
  }
}
# Diagonalize symmetric m with two-sided rotations
_Jacobi2 â† { rotQ _ğ•£ m:
  n â† â‰ m
  GetSubmats â† { âŸ¨ğ•©âŠË˜m, Di mâŸ© }
  _applyRot â† { m (ğ”½ ğ”½âŒ¾â‰)â†© â‹„ ğ”½ _rotQ }
  Sweep â† nâ€¿GetSubmatsâ€¿_applyRot _JacobiSweep
  # Norm +Â´Ã—Ëœâ¥Šm stays constant; stop when off-diagonal part is small
  end â† (Ã—Ëœ1eÂ¯14) Ã— +Â´Ã—Ëœâ¥Šm
  Sweep _while_ {ğ•Š: end < +Â´Ã—Ëœ (<âŒœËœâ†•n)/â—‹â¥Šm} @
  # Return eigenvalues
  Di m
}
# No eigenvectors, slightly faster than symmetric_eigen.Decompose
# Eigenvalues_Symmetric â† { !2==ğ•© â‹„ !=Â´â‰¢ğ•© â‹„ âˆ¨ {Ë™}_Jacobi2 ğ•© }

# Eigendecomposition of symmetric matrix: eigenvalues, eigenvectors as rows
symmetric_eigen â† {
  Compose â‡ { ğ•Š dâ€¿q: q HâŠ¸MP d Ã— q }
  Verify â‡ { ğ•Š dâ€¿q:
    !2==q â‹„ !=Â´â‰¢q
    !1==d â‹„ ! d =â—‹â‰  q
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q  # Unitary
  }
  Inverse â‡ Compose Ã·âŒ¾âŠ‘
  Solve â‡ { dâ€¿q ğ•Š b: q HâŠ¸MP d Ã·Ëœ q MP b }
  Determinant â‡ { ğ•Š dâ€¿Â·: Ã—Â´d }
  # Parallel Jacobi method
  Decompose â‡ {
    !2==ğ•© â‹„ !=Â´â‰¢ğ•©
    q â† =âŒœËœâ†•â‰ ğ•©               # Eigenvectors
    d â† {{q ğ”½â†©}} _Jacobi2 ğ•©  # Eigenvalues
    (â’d)âŠ¸âŠÂ¨ dâ€¿q
  }
}

# Singular Value Decomposition (compact shapes)
svd â† {
  Compose â‡ { ğ•Š uâ€¿dâ€¿v: {uâ‰¥â—‹â‰ v?  u MP  d  Ã—  v ;
                               (u Ã—â‰1 d) MP v } }
  Verify â‡ { ğ•Š uâ€¿dâ€¿v:
    !1==d
    {
      !2==ğ•© â‹„ !â‰¤Â´â‰¢ğ•© â‹„ !d=â—‹â‰ ğ•©
      ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- MPâŸœâ‰ ğ•©
    }Â¨ âŸ¨â‰u, vâŸ©
  }
  Inverse â‡ Compose Hâ€¿Ã·â€¿H {ğ•ğ•©}Â¨ âŒ½
  Solve â‡ { uâ€¿dâ€¿v ğ•Š b: v HâŠ¸MP d Ã·Ëœ u HâŠ¸MP b }
  AbsDeterminant â‡ { ğ•Š Â·â€¿dâ€¿Â·: Ã—Â´d }
  # Parallel Jacobi method
  Decompose â‡ {
    !2==ğ•©
    # Arrange the rows to be longer for faster computation
    tr â† >Â´â‰¢ğ•©
    m â† â‰âŸtr ğ•©
    # Symmetric eigendecomposition of MPâŸœâ‰ m
    # We maintain m throughout with one-sided rotations
    q â† =âŒœËœâ†•nâ†â‰ m  # Left-singular vectors (as rows)
    GetSubmats â† { âŸ¨+ËË˜mÃ—ğ•©âŠm, +ËË˜Ã—ËœmâŸ© }
    _applyRot â† { m ğ”½â†© â‹„ q ğ”½â†© }
    Sweep â† nâ€¿GetSubmatsâ€¿_applyRot _JacobiSweep
    # Stopping criterion from Demmel and VeseliÄ‡ 1992
    Sweep _while_ {ğ•Š: aâ†MPâŸœâ‰m â‹„ âˆ¨Â´â¥Š (<âŒœËœâ†•n) âˆ§ (|a) > Ã—âŒœËœâˆš1eÂ¯14Ã—Di a} @
    # Arrange as decomposition
    d â† +ËË˜âŒ¾(Ã—Ëœ) m  # Singular values
    â‰âŒ¾âŠ‘ âŒ½âŸtr (â’d)âŠ¸âŠÂ¨ âŸ¨q, d, mÃ·dâŸ©
  }
}

# List of eigenvalues of ğ•©; each complex one is returned as realâ€¿imag
# Implicit QR algorithm with double shifts
Eigenvalues â† {
  !2==ğ•© â‹„ !=Â´â‰¢ğ•© â‹„ !1â‰¤â‰ ğ•©
  # 2Ã—2 trace + determinant, and eigenvalues
  TrDet â† Trace â‹ˆ Â·-Â´Ã—âŸœâŒ½Ë
  Eig2 â† { bâ€¿câ†TrDet ğ•© â‹„ bÃ·â†©2 â‹„ b (0â‰¤s)â—¶âŸ¨â‹ˆÂ¨,+âŸ© -âŠ¸â‹ˆâˆš|sâ†(Ã—Ëœb)-c }

  # Householder reflection HHğ•© sends ğ•© to a multiple of ğ•©â‰ âŠ¸â†‘1
  HH â† {
    S â† (+Â´Ã—Ëœ1â†“ğ•©)+Ã—Ëœ
    vd â† (2Ã·Â·0âŠ¸=âŠ¸+Sâˆ˜âŠ‘)âŠ¸Ã— v â† (âˆšâˆ˜SÃ—Â¯1â‹†<âŸœ0)âŠ¸+âŒ¾âŠ‘ ğ•©
    âŸ¨âŠ¢-vdÃ—âŒœv+Ëâˆ˜Ã—âŠ¢, âŠ¢-vdÃ—âŒœËœ+Ëâˆ˜Ã—âŸœvË˜âŸ©  # Left and right applications
  }

  # Return a Hessenberg matrix (satisfies 0âŠ¸â‰ <1â‰¥-âŒœËœâˆ˜â†•âˆ˜â‰ ) similar to ğ•©
  Hessenberg â† {
    # Reflect to zero out column ğ•¨âŠË˜ğ•© below row 1+ğ•¨
    Dr â† (1+ğ•¨)âŠ¸â†“
    HLâ€¿HR â† HH ğ•¨âŠË˜Dr ğ•© â‹„ HLâŒ¾Dr HRâŒ¾(DrË˜) ğ•©
  }Â´âŸœ(âŒ½âˆ˜â†•0âŒˆâ‰ -2Ë™)

  # Double QR step with eigenvalues of Â¯2â€¿Â¯2â†‘ğ•© as shifts
  Step â† {ğ•Ša:
    # First column determines the result, use c to construct it
    sâ€¿t â† TrDet Â¯2â€¿Â¯2â†‘a
    l â† 1â€¿0 âŠ‘ h â† 2â€¿2â†‘a
    c â† âŸ¨t + +Â´âŸ¨s-ËœâŠ‘h,lâŸ©Ã—âŠhâŸ© âˆ¾ l Ã— âŸ¨s-ËœTrace h, 2â€¿1âŠ‘aâŸ©
    # After reflecting by c we do the same reduction as Hessenberg,
    # but entries more than 2 below the diagonal will always be 0
    n â† â‰ a  # â‰¥3
    j â† 3â†‘Ë˜ i â† â¥ŠâŸœ(â†•Ã—Â´)3â€¿n
    Refl â† { HLâ€¿HR â† HH ğ•© â‹„ a (HLâŒ¾(iâŠâ¥Š) HRâŒ¾(jâŠâ¥Š))â†© }
    ReflJ â† { jâˆ¾â†©n+jâ†‘Ëœ-n>â‰ j â‹„ Refl ğ•© } # Extend j first
    ReflJ c
    { i+â†©nâ‹„j+â†©1 â‹„ ReflJ ğ•© âŠË˜ 3â†‘(ğ•©+1)â†“a â‹„ iâ†“Ë˜Ëœâ†©1 }Â¨ â†•n-3
    iâ†“Ëœâ†©1â‹„jâ†“Ë˜Ëœâ†©1 â‹„ Refl (n-3) âŠË˜ Â¯2â†‘a
    a
  }

  # Split into irreducible components; implicit QR requires these
  Break â† {
    sd â† ((1-Ëœ1âŠ¸+Ã—1â†“â†•)â‰ ğ•©)âŠâ¥Šğ•©             # Subdiagonal
    z â† (|sd) â‰¤ 1eÂ¯14 Ã— 1 (â†“+-âŠ¸â†“)| Di ğ•©  # Mask of near-zero
    (â‹ˆËœâŠğ•©Ë™)Â¨ âŠ” +`0âˆ¾z
  }

  Decompose â† {âˆ¾ğ•ŠâŸ(2<â‰ âˆ˜âŠ‘)âˆ˜â‹ˆÂ¨ Breakâˆ˜Stepâˆ˜âŠ‘_while_(1=â‰ ) ğ•©}
  âˆ¾ (1<â‰ )â—¶âŠâ€¿Eig2Â¨ DecomposeâŸ(2<â‰ ğ•©) Break Hessenberg ğ•©
}
