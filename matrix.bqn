âŸ¨
  MP, H, Trace, Determinant
  Inverse, Solve, Eigenvalues, CharPoly
  lTri, uTri, qr, lup, cholesky, symmetric_eigen, svd
âŸ©â‡

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ  # matrix product
H  â† +â‰        # conjugate transpose
Di â† 0â€¿0â‰âŠ¢     # diagonal
_while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}

Trace â† +Â´Di

# Lower (lâ†1) or upper (lâ†0) triangular matrix
LUTri â† {ğ•Š l:
  Verify â‡ (lâŠ‘>â€¿<){
    ! 2==ğ•©
    ! âˆ§Â´â¥Š (ğ•©=0) â‰¥ ğ”½âŒœÂ´â†•Â¨â‰¢ğ•©
  }
  Determinant â‡ (âˆ§Â´0âŠ¸â‰ )â—¶âŸ¨0,Ã—Â´âŸ©Di  # Might contain âˆ or NaN
  # Inverse by recursive blocking
  pâ€¿c â† {ğ•Ëœ}Â¨âŸl â‹ˆâ€¿â‰
  Inverse â‡ {
    1â‰¥â‰ ğ•© ? Ã·ğ•© ;
    l â† â‰ ğ•©
    m â† âŒˆlÃ·2
    aiâ€¿di â† InverseÂ¨ mâ€¿m(â†‘Pâ†“)ğ•©
    b â† (m P m-l)â†‘ğ•©
    x â† - ai MP b MP di
    z â† 0 â¥ŠËœ (l-m) P m
    âˆ¾ (ai P x) C (z P di)
  }
  # Forward or backward substitution
  sâ†Â¯1â‹†Â¬l â‹„ jâ†l-1 â‹„ rev â† lâŠ‘{ğ”½âŒ¾âŒ½}â€¿{ğ”½}
  Solve â‡ { t ğ•Š b:
    ! t=â—‹â‰ b
    >{
      newâ†bÃ·â—‹(jâŠ¸âŠ)ğ•©
      bâ†©b-âŸœ(Ã—âŒœâŸœnew)â—‹(sâŠ¸â†“)ğ•©
      new
    }Â¨âˆ˜((sÃ—â†•âˆ˜â‰ )â†“Â¨âŠ¢)_rev <Ë˜â‰t
  }
}
uTriâ€¿lTri â†  LUTriÂ¨ â†•2

# LU decomposition with pivoting
lup â† {
  Compose â‡ { ğ•Š pâ€¿lâ€¿u: pâŠ¸âŠË˜ l MP u }
  Verify â‡ { ğ•Š pâ€¿lâ€¿u:
    ! â‰¤Â´ mâ€¿n â† â‰¢u
    ! mâ€¿m â‰¡ â‰¢l
    ! (âˆ§p) â‰¡ â†•n
    uTri.Verify u
    lTri.Verify l
    ! âˆ§Â´ 1 = Di l
  }
  Inverse â‡ { ğ•Š pâ€¿lâ€¿u: p âŠ u uTri.Solve lTri.Inverse l }
  Solve â‡ { pâ€¿lâ€¿u ğ•Š ğ•©: p âŠ u uTri.Solve l lTri.Solve ğ•© }
  Determinant â‡ { ğ•Š pâ€¿lâ€¿u:
    s â† Â¯1â‹†+Â´âˆ¾(â‰ â†‘â†‘)âŠ¸>p  # Sign of permutation
    s Ã— uTri.Determinant u
  }

  Decompose â‡ {
    1 â‰¥ â‰ ğ•© ? âŸ¨â†•Â¯1âŠ‘â‰¢ğ•©, 1â¥ŠËœâ‹ˆËœâ‰ ğ•©, ğ•©âŸ© ;
    mâ€¿nâ†â‰¢aâ†ğ•©
    [i,lc,d,ur] â† â‰>{ğ•Š:
      i â† âŠ‘âŠâŸœ(âŒˆÂ´)|r0â†âŠa  # Pivot
      d â† âŸ¨i-n-ğ•©,i+1âŸ©    # Drop amounts to cut out i
      a00â€¿a10 â† (âŠ‘â‹ˆ1âŠ¸â†“) iâŠË˜a
      a01 â† âˆ¾â†“âŸœr0Â¨d
      a â†© (âˆ¾Ë˜Â´(1âŠ¸â‹ˆâ†“aË™)Â¨d) - (cnâ†a10Ã·0âŠ¸=âŠ¸+a00)Ã—âŒœa01
      iâ€¿cnâ€¿a00â€¿a01
    }Â¨ â†•m-1
    p â† ((<â†•nÂ¬m)(âŠ£âˆ¾{ğ•©âˆ¾ğ•©âŠ¸â‰¤âŠ¸+ğ•¨}`)âŠ¢)âŒ¾âŒ½ i
    l â† â‰> (-m)â†‘Â¨1âˆ¾Â¨lcâˆ¾<â†•0
    u â†  > (-n)â†‘Â¨(dâˆ¾Â¨(1â†“p)âŠÂ¨ur)âˆ¾<â¥Ša
    âŸ¨â‹âŠ‘p, l, uâŸ©
  }

  # Recursive method, can return NaN for singular matrices
  DecomposeNonSingular â‡ (0<â‰ )â—¶{ âŸ¨â†•Â¯1âŠ‘â‰¢ğ•© , 0â€¿0â¥Š0 , ğ•©âŸ© }â€¿{ LU:
    1<m âŠ£ mâ€¿n â† â‰¢ğ•© ?
    m2 â† âŒˆmÃ·2 â‹„ S â† m2(â†‘â‹ˆâ†“)âŠ¢
    a1â€¿a2 â† Sğ•©
    p1â€¿l1â€¿u1 â† LU a1
    g1â€¿g2 â† Sâ‹p1
    fe1â† (g1âŠ¸âŠË˜ a2) MP uTri.Inverse m2 â†‘Ë˜ u1
    g  â† (g2âŠ¸âŠË˜ a2) -        fe1 MP m2 â†“Ë˜ u1
    p2â€¿l2â€¿u2 â† LU g
    p3 â† m2(â†•âˆ˜âŠ£âˆ¾+)p2
    h  â† (â‹p3)âŠ¸âŠË˜ u1
    z  â† m2â€¿(m-m2)â¥Š0
    âŸ¨ p1âŠp3 , âˆ¾l1â€¿zâ‰fe1â€¿l2 , hâˆ¾(-n)â†‘Ë˜u2 âŸ©
  ;
    p â† ((â‰ v)|+Â´âˆ§`0=v) {âŒ½âŒ¾(0â€¿ğ•¨âŠ¸âŠ)ğ•©}âŸ(0<âŠ£) â†•â‰ vâ†â¥Šğ•©
    âŸ¨p , â‰â‰1 , â‰pâŠvâŸ©
  }
}

# QR decomposition
qr â† {
  Compose â‡ MPÂ´
  Verify â‡ { ğ•Š qâ€¿r:
    ! âˆ§Â´2==Â¨ğ•©
    ! âˆ§Â´â‰¥â€¿={ğ•Â´â‰¢ğ•©}Â¨ğ•©
    uTri.Verify r
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q
  }
  Inverse â‡ uTri.InverseâŠ¸MPâŸœHËœÂ´
  Solve â‡ { qâ€¿r ğ•Š b: r uTri.Solve (H q) MP b }
  AbsDeterminant â‡ { ğ•Š qâ€¿r: | uTri.Determinant r }

  # Recursive Gram-Schmidt
  Decompose â‡ {
    !2==ğ•© â‹„ !â‰¥Â´â‰¢ğ•©
    {QR: 1<nâ†Â¯1âŠ‘â‰¢ğ•© ?
      m â†âŒˆnÃ·2
      a0â†mâ†‘Ë˜ğ•©
      a1â†mâ†“Ë˜ğ•©
      q0â€¿r0â†QR a0
      q1â€¿r1â†QR a1 - q0 MP t â† q0 HâŠ¸MP a1
      âŸ¨q0âˆ¾Ë˜q1 , (r0âˆ¾Ë˜t)âˆ¾(-n)â†‘Ë˜r1âŸ©
    ;
      ğ•© (Ã·âŸœâŠ‘ â‹ˆ âŠ¢) âˆš HâŠ¸MP ğ•©
    }ğ•©
  }

  # Householder reflections: slower; more stable
  DecomposeHH â‡ { ğ•Š a:
    mâ€¿nâ†â‰¢a
    qâ†=âŒœËœâ†•m
    Step â† {ğ•Šk:
      nz â† +Â´âˆ˜|âŒ¾(Ã—Ëœ) z â† âŸ¨k+â†•m-k,<kâŸ©âŠa
      v â† -(nzÃ—Ã—)âŠ¸+âŒ¾âŠz
      v2 â† 2 Ã— (+v) Ã· nvâ†+Â´|Ã—Ëœv
      nvâ‰¥Ã—Ëœ2â‹†Â¯52 ? aâ€¿q -âŸœ((m-âŠ¸â†‘v) Ã—âŒœ v2 +Ëâˆ˜Ã— (-â‰ v)âŠ¸â†‘)Â¨â†© ; @
    }
    StepÂ¨ â†•n
    âŸ¨H q, aÃ—mâ‰¤âŒœâ—‹â†•nâŸ©
  }
}

# Default implementations
Inverse â† qr.Inverse qr.Decompose
Solve â† qr.Decompose âŠ¸ qr.Solve
Determinant â† (âŠ¢Ã—=âˆ§3âŠ¸â‰¥)Â´âˆ˜â‰¢â—¶âŸ¨
  lup.Determinant lup.Decompose
  âŠ‘                     # 1Ã—1
  -Â´Ã—âŸœâŒ½Ë                # 2Ã—2
  +Â´(â†•3)(Ã—ËâŒ½Ë˜){ğ”½--âŠ¸ğ”½}âŠ¢  # 3Ã—3
âŸ©

# Cholesky decomposition
cholesky â† {
  Verify â‡ lTri.Verify
  Compose â‡ MPâŸœH
  Inverse â‡ HâŠ¸MP lTri.Inverse
  Solve â‡ Hâˆ˜âŠ£ uTri.Solve lTri.Solve
  Determinant â‡ Ã—Ëœ lTri.Determinant
  Decompose â‡ { 1<nâ†â‰ ğ•© ?
    m â† âŒˆnÃ·2 â‹„ dâ†m-n
    xâ€¿yâ€¿z â† âŸ¨mâ€¿m,mâ€¿d,dâ€¿dâŸ© â†‘Â¨ <ğ•©
    l0 â† ğ•Š x
    l1 â† ğ•Š z - (tâ†H ly) MP ly â† l0 lTri.Solve y
    âˆ¾ âŸ¨l0,âŸ¨m,-dâŸ©â¥Š0âŸ©â‰âŸ¨t,l1âŸ©
  ;
    ! 0<âŠ‘ğ•©
    âˆšğ•©
  }
}

# Faddeev-LeVerrier algorithm
CharPoly â† {
  !2==ğ•© â‹„ !=Â´â‰¢ğ•©
  idâ†=âŒœËœâ†•nâ†â‰ ğ•©
  câ†-Trace mâ†m0â†ğ•©
  1â€¿c âˆ¾ c { Trace m â†© m0 MP m+ğ•©Ã—id }âŠ¸Ã·` -2+â†•n-1
}

# Shared code for one-sided or two-sided parallel Jacobi method
_JacobiSweep â† { nâ€¿GetSubmatsâ€¿_applyRot _ğ•£:
  # Diagonalize each pair j, jâŠ‘i with a rotation
  # Duplicates the arithmetic for sin and cos but it vectorizes well
  Layer â† { ğ•Š i:
    offâ€¿diag â† GetSubmats i  # âŸ¨ğ•©âŠË˜m, Di mâŸ© to diagonalize symmetric m
    # Required rotation is determined by the ratio uÃ·p
    d â† Ã—i-â†•n
    p â† (2 Ã— dâ‰ 0) Ã— off         # Force to 0 for non-pairs d=0
    u â† (d Ã— iâŠ¸âŠâŠ¸- diag) â‹† pâ‰ 0  # Must be nonzero if p=0
    t â† 2 Ã— v â† p +âŒ¾(Ã—Ëœ) u
    cos â† âˆš(v+|u)Ã·t
    sin â† (dÃ—Â¯1â‹†u<0) Ã— pÃ·tÃ—cos
    (cosâŠ¸Ã— - sinÃ—iâŠ¸âŠ)_applyRot
    @
  }
  # A sweep hits each (unordered) pair of distinct indices once
  r â† âŒ½â†•p â† n-Â¬2|n
  {ğ•Š:
    2|n? (LayerâŒ½âŸœr)Â¨ r;
    (p|(nÃ·2)Ã—â†•p) {Layer ğ•¨âˆ¾ËœpâŒ¾(ğ•¨âŠ¸âŠ‘) ğ•©âŒ½r}Â¨ r
  }
}

# Eigendecomposition of symmetric matrix: eigenvalues, eigenvectors as rows
symmetric_eigen â† {
  Compose â‡ { ğ•Š dâ€¿q: q HâŠ¸MP d Ã— q }
  Verify â‡ { ğ•Š dâ€¿q:
    !2==q â‹„ !=Â´â‰¢q
    !1==d â‹„ ! d =â—‹â‰  q
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q  # Unitary
  }
  Inverse â‡ Compose Ã·âŒ¾âŠ‘
  Solve â‡ { dâ€¿q ğ•Š b: q HâŠ¸MP d Ã·Ëœ q MP b }
  Determinant â‡ { ğ•Š dâ€¿Â·: Ã—Â´d }
  # Parallel Jacobi method
  Decompose â‡ { ğ•Š m:
    !2==m â‹„ !=Â´â‰¢m
    # Diagonalize with two-sided rotations
    q â† =âŒœËœâ†•nâ†â‰ m  # Eigenvectors
    GetSubmats â† { âŸ¨ğ•©âŠË˜m, Di mâŸ© }
    _applyRot â† { m (ğ”½ ğ”½âŒ¾â‰)â†© â‹„ q ğ”½â†© }
    Sweep â† nâ€¿GetSubmatsâ€¿_applyRot _JacobiSweep
    # Norm +Â´Ã—Ëœâ¥Šm stays constant; stop when off-diagonal part is small
    end â† (Ã—Ëœ1eÂ¯14) Ã— +Â´Ã—Ëœâ¥Šm
    Sweep _while_ {ğ•Š: end < +Â´Ã—Ëœ (<âŒœËœâ†•n)/â—‹â¥Šm} @
    # Sort eigenvalues descending
    i â† â’d â† Di m
    âŸ¨iâŠd, iâŠqâŸ©
  }
}

# Singular Value Decomposition (compact shapes)
svd â† {
  Compose â‡ { ğ•Š uâ€¿dâ€¿v: {uâ‰¥â—‹â‰ v?  u MP  d  Ã—  v ;
                               (u Ã—â‰1 d) MP v } }
  Verify â‡ { ğ•Š uâ€¿dâ€¿v:
    !1==d
    {
      !2==ğ•© â‹„ !â‰¤Â´â‰¢ğ•© â‹„ !d=â—‹â‰ ğ•©
      ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- MPâŸœâ‰ ğ•©
    }Â¨ âŸ¨â‰u, vâŸ©
  }
  Inverse â‡ Compose Hâ€¿Ã·â€¿H {ğ•ğ•©}Â¨ âŒ½
  Solve â‡ { uâ€¿dâ€¿v ğ•Š b: v HâŠ¸MP d Ã·Ëœ u HâŠ¸MP b }
  AbsDeterminant â‡ { ğ•Š Â·â€¿dâ€¿Â·: Ã—Â´d }
  # Parallel Jacobi method
  Decompose â‡ {
    !2==ğ•©
    # Arrange the rows to be longer for faster computation
    tr â† >Â´â‰¢ğ•©
    m â† â‰âŸtr ğ•©
    # Symmetric eigendecomposition of MPâŸœâ‰ m
    # We maintain m throughout with one-sided rotations
    q â† =âŒœËœâ†•nâ†â‰ m  # Left-singular vectors (as rows)
    GetSubmats â† { âŸ¨+ËË˜mÃ—ğ•©âŠm, +ËË˜Ã—ËœmâŸ© }
    _applyRot â† { m ğ”½â†© â‹„ q ğ”½â†© }
    Sweep â† nâ€¿GetSubmatsâ€¿_applyRot _JacobiSweep
    # Stopping criterion from Demmel and VeseliÄ‡ 1992
    Sweep _while_ {ğ•Š: aâ†MPâŸœâ‰m â‹„ âˆ¨Â´â¥Š (<âŒœËœâ†•n) âˆ§ (|a) > Ã—âŒœËœâˆš1eÂ¯14Ã—Di a} @
    # Arrange as decomposition
    d â† +ËË˜âŒ¾(Ã—Ëœ) m  # Singular values
    â‰âŒ¾âŠ‘ âŒ½âŸtr (â’d)âŠ¸âŠÂ¨ âŸ¨q, d, mÃ·dâŸ©
  }
}

# List of eigenvalues of ğ•©
# QR algorithm with Hessenberg reduction and Wilkinson shifts
# Returns NaNs or fails to converge if there are complex eigenvalues
Eigenvalues â† {
  Norm â† +Â´âŒ¾(Ã—Ëœ)
  # Return a Hessenberg matrix (0âŠ¸â‰ <1â‰¥-âŒœËœâˆ˜â†•âˆ˜â‰ ) similar to ğ•©
  Hessenberg â† {
    v â† (-â‰ ğ•©) â†‘ {((Normğ•©)Ã—Â¯1â‹†<âŸœ0)âŠ¸+âŒ¾âŠ‘ ğ•©} (1+ğ•¨)â†“ğ•¨âŠË˜ğ•©
    # Multiply on both sides by symmetric orthogonal matrix id-2Ã—uÃ—âŒœu
    # where u â† vÃ·Norm v
    v2 â† 2 Ã— v Ã· 0âŠ¸=âŠ¸+ +Â´Ã—Ëœv
    (âŠ¢-vÃ—âŒœv2+Ëâˆ˜Ã—âŠ¢) (âŠ¢-vÃ—âŒœËœ+Ëâˆ˜Ã—âŸœv2Ë˜) ğ•©
  }Â´âŸœ(âŒ½âˆ˜â†•0âŒˆâ‰ -2Ë™)

  # Shift based on eigenvalues of a symmetric matrix
  WilkinsonShift â† { ğ•Šaâ€¿Â·â€¿bâ€¿c:
    d â† 2Ã·Ëœa-c â‹„ b2 â† Ã—Ëœb
    c - b2 0âŠ¸â‰ â—¶0â€¿Ã· d + (Ã—d) Ã— b2âŠ¸+âŒ¾(Ã—Ëœ)d
  }

  # Obtain r MP q, where ğ•©â‰¡q MP r is a QR decomposition
  QRev â† {ğ•Ša:
    Giv â† { â‰âŸœ(-âŒ¾âŠ‘âŒ½) Ã·âŸœNorm âŸ¨ğ•¨+â†•2,<ğ•¨âŸ©âŠğ•© }  # Givens rotation matrix, transposed
    n â† â‰ ğ•©
    iâ†â¥ŠâŸœ(â†•Ã—Â´)2â€¿n  # First two rows
    gs â† { gâ†ğ•© Giv a â‹„ a gâŠ¸MPâŒ¾(iâŠâ¥Š)â†© â‹„ iâ†“Ëœâ†©0â€¿1â‹„i+â†©n â‹„ g }Â¨ â†•n-1
    iâ†©â‰Â¯1â€¿0 â‹„ a { i+â†©1â‹„iâˆ¾â†©n+Â¯1â†‘i â‹„ MPâŸœ(â‰ğ•¨)âŒ¾(iâŠâ¥Š)ğ•© }Â´ âŒ½gs
  }

  # Get one eigenvalue with QR
  QRAlg â† {
    mu â† WilkinsonShift â¥ŠÂ¯2â€¿Â¯2â†‘ğ•©
    QRevâŒ¾(-âŸœ(muÃ—=âŒœËœâ†•â‰ ğ•©)) ğ•©
  }_while_(1eÂ¯10 < Â·|Â¯1â€¿Â¯2âŠ¸âŠ‘)

  { 1â‰¥â‰ ğ•© ? 1â¥Šğ•© ; Â¯1â€¿Â¯1 (ğ•Šâˆ˜â†“âˆ¾ËœâŠ‘) QRAlg ğ•© } Hessenberg ğ•©
}
