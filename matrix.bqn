âŸ¨
  MP, H, Trace, Determinant
  Inverse, Solve, Eigenvalues
  lTri, uTri, qr, lup, cholesky
âŸ©â‡

MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ  # matrix product
H  â† +â‰        # conjugate transpose
Di â† 0â€¿0â‰âŠ¢     # diagonal

Trace â† +Â´Di

# Lower (lâ†1) or upper (lâ†0) triangular matrix
LUTri â† {ğ•Š l:
  Verify â‡ (lâŠ‘>â€¿<){
    ! 2==ğ•©
    ! âˆ§Â´â¥Š (ğ•©=0) â‰¥ ğ”½âŒœÂ´â†•Â¨â‰¢ğ•©
  }
  Determinant â‡ Ã—Â´Di
  # Inverse by recursive blocking
  pâ€¿c â† {ğ•Ëœ}Â¨âŸl â‹ˆâ€¿â‰
  Inverse â‡ {
    1â‰¥â‰ ğ•© ? Ã·ğ•© ;
    l â† â‰ ğ•©
    m â† âŒˆlÃ·2
    aiâ€¿di â† InverseÂ¨ mâ€¿m(â†‘Pâ†“)ğ•©
    b â† (m P m-l)â†‘ğ•©
    x â† - ai MP b MP di
    z â† 0 â¥ŠËœ (l-m) P m
    âˆ¾ (ai P x) C (z P di)
  }
  # Forward or backward substitution
  sâ†Â¯1â‹†Â¬l â‹„ jâ†l-1 â‹„ rev â† lâŠ‘{ğ”½âŒ¾âŒ½}â€¿{ğ”½}
  Solve â‡ { t ğ•Š b:
    ! t=â—‹â‰ b
    >{
      newâ†bÃ·â—‹(jâŠ¸âŠ)ğ•©
      bâ†©b-âŸœ(Ã—âŒœâŸœnew)â—‹(sâŠ¸â†“)ğ•©
      new
    }Â¨âˆ˜((sÃ—â†•âˆ˜â‰ )â†“Â¨âŠ¢)_rev <Ë˜â‰t
  }
}
uTriâ€¿lTri â†  LUTriÂ¨ â†•2

# LU decomposition with pivoting
lup â† {
  Compose â‡ { ğ•Š pâ€¿lâ€¿u: pâŠ¸âŠË˜ l MP u }
  Verify â‡ { ğ•Š pâ€¿lâ€¿u:
    ! â‰¤Â´ mâ€¿n â† â‰¢u
    ! nâ€¿n â‰¡ â‰¢l
    ! (âˆ§p) â‰¡ â†•n
    uTri.Verify u
    lTri.Verify l
    ! âˆ§Â´ 1 = Di l
  }
  Inverse â‡ { ğ•Š pâ€¿lâ€¿u: (â‹p) âŠ (uTri.Inverse u) MP lTri.Inverse l }
  Solve â‡ { pâ€¿lâ€¿u ğ•Š ğ•©: (â‹p) âŠ u uTri.Solve l lTri.Solve ğ•© }
  Determinant â‡ { ğ•Š pâ€¿lâ€¿u:
    s â† Â¯1â‹†+Â´âˆ¾(â‰ â†‘â†‘)âŠ¸>p  # Sign of permutation
    s Ã— uTri.Determinant u
  }

  # Recursive method
  Decompose â‡ (0<â‰ )â—¶{ âŸ¨â†•Â¯1âŠ‘â‰¢ğ•© , 0â€¿0â¥Š0 , ğ•©âŸ© }â€¿{ LU:
    1<m âŠ£ mâ€¿n â† â‰¢ğ•© ?
    m2 â† âŒˆmÃ·2 â‹„ S â† m2(â†‘â‹ˆâ†“)âŠ¢
    a1â€¿a2 â† Sğ•©
    p1â€¿l1â€¿u1 â† LU a1
    g1â€¿g2 â† Sâ‹p1
    fe1â† (g1âŠ¸âŠË˜ a2) MP uTri.Inverse m2 â†‘Ë˜ u1
    g  â† (g2âŠ¸âŠË˜ a2) -        fe1 MP m2 â†“Ë˜ u1
    p2â€¿l2â€¿u2 â† LU g
    p3 â† m2(â†•âˆ˜âŠ£âˆ¾+)p2
    h  â† (â‹p3)âŠ¸âŠË˜ u1
    z  â† m2â€¿(m-m2)â¥Š0
    âŸ¨ p1âŠp3 , âˆ¾l1â€¿zâ‰fe1â€¿l2 , hâˆ¾(-n)â†‘Ë˜u2 âŸ©
  ;
    p â† (+Â´âˆ§`0=v) {âŒ½âŒ¾(0â€¿ğ•¨âŠ¸âŠ)ğ•©}âŸ(0<âŠ£) â†•â‰ vâ†â¥Šğ•©
    âŸ¨p , â‰â‰1 , â‰pâŠvâŸ©
  }
}

# QR decomposition
qr â† {
  Compose â‡ MPÂ´
  Verify â‡ { ğ•Š qâ€¿r:
    ! âˆ§Â´2==Â¨ğ•©
    ! âˆ§Â´â‰¥â€¿={ğ•Â´â‰¢ğ•©}Â¨ğ•©
    uTri.Verify r
    ! âˆ§Â´ â¥Š 5eÂ¯14â‰¥| (=âŒœÂ´â†•Â¨âˆ˜â‰¢)âŠ¸- HâŠ¸MP q
  }
  Inverse â‡ uTri.InverseâŠ¸MPâŸœHËœÂ´
  Solve â‡ { qâ€¿r ğ•Š b: r uTri.Solve (H q) MP b }
  AbsDeterminant â‡ { ğ•Š qâ€¿r: | uTri.Determinant r }

  # Recursive Gram-Schmidt
  Decompose â‡ {
    !2==ğ•© â‹„ !â‰¥Â´â‰¢ğ•©
    {QR: 1<nâ†Â¯1âŠ‘â‰¢ğ•© ?
      m â†âŒˆnÃ·2
      a0â†mâ†‘Ë˜ğ•©
      a1â†mâ†“Ë˜ğ•©
      q0â€¿r0â†QR a0
      q1â€¿r1â†QR a1 - q0 MP t â† q0 HâŠ¸MP a1
      âŸ¨q0âˆ¾Ë˜q1 , (r0âˆ¾Ë˜t)âˆ¾(-n)â†‘Ë˜r1âŸ©
    ;
      ğ•© (Ã·âŸœâŠ‘ â‹ˆ âŠ¢) âˆš HâŠ¸MP ğ•©
    }ğ•©
  }

  # Householder reflections: slower; more stable
  DecomposeHH â‡ { ğ•Š a:
    mâ€¿nâ†â‰¢a
    qâ†=âŒœËœâ†•m
    Step â† {ğ•Šk:
      iâ†k+â†•m-k â‹„ niâ†nÃ—i â‹„ _colâ†{(ğ•—+ni)âŠâ¥Š} #{âŸ¨i,<ğ•—âŸ©âŠ¸âŠ}
      Normâ†+Â´âˆ˜|âŒ¾(Ã—Ëœ)
      nzâ†Norm zâ†k _col a
      nvâ†Norm vâ†-(nzÃ—Ã—)âŠ¸+âŒ¾âŠz
      vÃ·â†©nv
      HH â† {-âŸœ(v Ã— 2 Ã— (+v) +Â´âˆ˜Ã— âŠ¢)âŒ¾(ğ•¨_col) ğ•©}Â´âŸœâŒ½
      nvâ‰¥2â‹†Â¯52 ? aâ€¿q HHâŸœâ†•Â¨â†© nâ€¿m ; @
    }
    StepÂ¨ â†•n
    âŸ¨H q, aÃ—mâ‰¤âŒœâ—‹â†•nâŸ©
  }
}

# Cholesky decomposition
cholesky â† {
  Verify â‡ lTri.Verify
  Compose â‡ MPâŸœH
  Inverse â‡ HâŠ¸MP lTri.Inverse
  Solve â‡ Hâˆ˜âŠ£ uTri.Solve lTri.Solve
  Determinant â‡ Ã—Ëœ lTri.Determinant
  Decompose â‡ { 1<nâ†â‰ ğ•© ?
    m â† âŒˆnÃ·2 â‹„ dâ†m-n
    xâ€¿yâ€¿z â† âŸ¨mâ€¿m,mâ€¿d,dâ€¿dâŸ© â†‘Â¨ <ğ•©
    l0 â† ğ•Š x
    l1 â† ğ•Š z - (tâ†H ly) MP ly â† l0 lTri.Solve y
    âˆ¾ âŸ¨l0,âŸ¨m,-dâŸ©â¥Š0âŸ©â‰âŸ¨t,l1âŸ©
  ;
    ! 0<âŠ‘ğ•©
    âˆšğ•©
  }
}

# Default implementations
Inverse â† qr.Inverse qr.Decompose
Solve â† qr.Decompose âŠ¸ qr.Solve
Determinant â† lup.Determinant lup.Decompose

# List of eigenvalues of ğ•©
# QR algorithm with Hessenberg reduction and Wilkinson shifts
# Returns NaNs or fails to converge if there are complex eigenvalues
Eigenvalues â† {
  # Return a Hessenberg matrix (0âŠ¸â‰ <1â‰¥-âŒœËœâˆ˜â†•âˆ˜â‰ ) similar to ğ•©
  Hessenberg â† {
    v â† (-â‰ ğ•©) â†‘ {((+Â´âŒ¾(Ã—Ëœ)ğ•©)Ã—Â¯1â‹†<âŸœ0)âŠ¸+âŒ¾âŠ‘ ğ•©} (1+ğ•¨)â†“ğ•¨âŠË˜ğ•©
    # Multiply on both sides by symmetric orthogonal matrix id-2Ã—uÃ—âŒœu
    # where u â† vÃ·+Â´âŒ¾(Ã—Ëœ)v
    v2 â† 2 Ã— v Ã· +Â´Ã—Ëœv
    (âŠ¢-vÃ—âŒœv2+Ëâˆ˜Ã—âŠ¢) (âŠ¢-vÃ—âŒœËœ+Ëâˆ˜Ã—âŸœv2Ë˜) ğ•©
  }Â´âŸœ(â†•â‰ -2Ë™)

  # Shift based on eigenvalues of a symmetric matrix
  WilkinsonShift â† { ğ•Šaâ€¿Â·â€¿bâ€¿c:
    d â† 2Ã·Ëœa-c â‹„ b2 â† Ã—Ëœb
    c - b2 Ã· d + (Ã—d) Ã— b2âŠ¸+âŒ¾(Ã—Ëœ)d
  }

  # Get one eigenvalue with QR
  QRAlg â† {
    mu â† WilkinsonShift â¥ŠÂ¯2â€¿Â¯2â†‘ğ•©
    # TODO: custom QR decomposition for speed
    MPËœÂ´âˆ˜qr.DecomposeHHâŒ¾(-âŸœ(muÃ—=âŒœËœâ†•â‰ ğ•©)) ğ•©
  }â€¢_while_(1eÂ¯10 < Â·|Â¯1â€¿Â¯2âŠ¸âŠ‘)

  { 1â‰¥â‰ ğ•© ? 1â¥Šğ•© ; Â¯1â€¿Â¯1 (âŠ‘âˆ¾ğ•Šâˆ˜â†“) QRAlg Hessenberg ğ•© } ğ•©
}
