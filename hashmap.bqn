# keys HashMap vals:     return a mutable hash map h implementing
#   h.Count any:         return number of keys defined by h
#   h.Has key:           return 1 if key is present and 0 otherwise
#   [default] h.Get key: return corresponding value, default if not found
#   key h.Set val:       set value (may overwrite); return h
#   h.Delete key:        remove corresponding value; return h

# ğ•—_hash is a function returning index in (2â‹†n)-length table
âŸ¨_hashâŸ© â† {
  base â† 2 â‹† bâ†32
  _hash â‡ { bits _ğ•£:
    ! 1â‰¤bits
    dâ€¿mâ†b(âŒˆâˆ˜Ã·Ëœâ‹ˆ|)bits
    mod â† (0<m)âŠ‘âŸ¨âŠ¢,(2â‹†m)âŠ¸|âŸ©
    acc â† (2âŒŠd-1)âŠ‘âŸ¨ModâŠ‘, (baseÃ—Modâˆ˜âŠ‘)+Â¯1âŠ¸âŠ‘, +âŸœ(baseâŠ¸Ã—)Â´Â·âŒ½ModâŒ¾âŠ‘âˆ˜â†‘âŸ©
    (-d) Acc â€¢Hash
  }
}

HashMap â‡ {ğ•©.Selfğ•©}âˆ˜{ keys ğ•Š vals: Selfâ‡{selfâ†©ğ•©}
  "HashMap: keys ğ•¨ and values ğ•© must be arrays" ! âˆ§Â´ (0=â€¢Type)Â¨keysâ€¿vals
  "HashMap: key and value arrays must have the same shape" ! keys â‰¡â—‹â‰¢ vals
  keysâ€¿vals â¥ŠÂ¨â†©
  hlenâ†bitsâ†tableâ†0 â‹„ Indâ†Nextâ†âŠ¢
  InitSize â† {
    hlen â†© 2 â‹† bits â†© 1+âŒˆ2â‹†â¼ 1âŒˆğ•©  # hlen â‰¥ 2Ã—len
    Ind â†© bits _hash
    Next â†© hlenâŠ¸>âŠ¸Ã— 1+âŠ¢
    table â†© hlen â¥Š Â¯1
  }
  ST â† {table ğ•¨âŒ¾(ğ•©âŠ¸âŠ‘)â†©â‹„@}
  Count â‡ {ğ•Š:len}

  # Lookup and modify
  Find â† { ğ•Š key:
    T â† ("Not found!"!Â¯1âŠ¸â‰ )âŠ¸âŠ¢ âŠ‘âŸœtable
    table âŠ‘Ëœ Nextâ€¢_while_(keyâ‰¢keysâŠ‘ËœT) Ind key
  }
  Get â‡ {
      ğ•Š key: vals âŠ‘Ëœ Find key ;
    d ğ•Š key: Nextâ€¢_while_(Â¯1âŠ¸â‰ â—¶âŸ¨0,âŠ¢{dâ†©ğ•¨â‹„ğ•©}âŸ(Â¬âŠ¢)keyâ‰¢âŠ‘âŸœkeysâŸ©âŠ‘âŸœtable) Ind key â‹„ d
  }
  tombstone â† {â‡}
  Delete â‡ { ğ•Š key:
    keys tombstoneâŒ¾((Find key)âŠ¸âŠ‘)â†©
    DecLen 1
    self
  }
  Has â‡ { ğ•Š key:
    hâ†1 â‹„ Nextâ€¢_while_(Â¯1âŠ¸â‰ â—¶âŸ¨{ğ•Š:hâ†©0},keyâ‰¢âŠ‘âŸœkeysâŸ©âŠ‘âŸœtable) Ind key â‹„ h
  }
  DefKey â† { ğ•Š key:
    Nextâ€¢_while_(Â¯1âŠ¸â‰ â—¶âŸ¨0,"Duplicate key"!keyâ‰¢âŠ‘âŸœkeysâŸ©âŠ‘âŸœtable) Ind key
  }
  Set â‡ { key ğ•Š val:
    New â† {len ST ğ•¨ â‹„ keysâˆ¾â†©<key â‹„ valsâˆ¾â†©<val â‹„ IncLen 1 â‹„ 0}
    Mod â† {vals valË™âŒ¾((ğ•¨âŠ‘table)âŠ¸âŠ‘)â†© â‹„ 0}
    Nextâ€¢_while_(Â¯1âŠ¸â‰ â—¶âŸ¨New,ModâŸ(Â¬âŠ¢)âŸœ(keyâ‰¢âŠ‘âŸœkeys)âŸ©âŸœ(âŠ‘âŸœtable)) Ind key
    self
  }

  # Resize
  Init â† {
    InitSize ğ•©
    (â†•ğ•©) STâŸœDefKeyÂ¨ keys
  }
  ClearTombs â† {ğ•Š:
    ! len â‰¡ +Â´ k â† tombstoneâŠ¸â‰¢Â¨ keys
    keysâ€¿vals kâŠ¸/Â¨â†©
    k
  }
  Renumber â† { # Based on filter ğ•©
    table âŠâ†© 1-Ëœ(ğ•©Ã—+`ğ•©)âˆ¾0
    @
  }
  IncLen â† {
    len +â†© ğ•©
    hlen â‰¥ 2 Ã— â‰ keys ? @ ;
    k â† ClearTombs@
    hlen â‰¥ 1.75 Ã— len ? Renumber k ;
    Init len
  }
  DecLen â† {
    len -â†© ğ•©
    hlen < 6 Ã— len ? @ ;
    ClearTombs@
    Init len
  }
  Init len â† â‰ keys
}
